<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NSOperation的进阶使用和简单探讨]]></title>
    <url>%2F2018%2F11%2F24%2FNSOperation%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E5%92%8C%E7%AE%80%E5%8D%95%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[本文将会从这多个方面探讨NSOperation类和NSOperationQueue类的相关内容 一、简介NSOperation的是iOS2.0推出的，通过NSThread实现的,但是效率的确一般。从OS X10.6和iOS4推出GCD时，又重写了NSOperation和NSOperationQueue，NSOperation和NSOperationQueue分别对应GCD的任务和队列，所以NSOPeration和NSOperationQueue是基于GCD更高一层的封装，而且完全地面向对象。但是比GCD更简单易用、代码可读性也更高。NSOperation和NSOperationQueue对比GCD会带来一点额外的系统开销，但是可以在多个操作Operation中添加附属。 二、知识概括从NSOperation的思维导图了解的这个类相关的整体的知识点： NSOperation和NSOperationQueue是基于GCD的更高一层的封装，分别对应GCD的任务和队列，完全地面向对象。可以通过start方法直接启动NSOperation子类对象，并且默认同步执行任务，将NSOperation子类对象添加到NSOperationQueue中，该队列默认并发的调度任务。 开启操作有二种方式，一是通过start方法直接启动操作，该操作默认同步执行，二是将操作添加到NSOperationQueue中，然后由系统从队列中获取操作然后添加到一个新线程中执行，这些操作默认并发执行。 具体实现如下：方式一：直接由NSOperation子类对象启动。首先将需要执行的操作封装到NSOperation子类对象中，然后该对象调用Start方法。方式二：当添加到NSOperationQueue对象中，由该队列对象启动操作。 将需要执行的操作封装到NSOperation子类对象中 将该对象添加到NSOperationQueue中 系统将NSOperation子类对象从NSOperationQueue中取出 将取出的操作放到一个新线程中执行 使用队列来执行操作，分为2个阶段：第一阶段：添加到线程队列的过程，是上图的步骤1和2。第二阶段：系统自动从队列中取出线程，并且自动放到线程中执行，是上图的步骤3和4。 接下来相关内容的总结： 1. NSOperationNSOperation是一个和任务相关的抽象类，不具备封装操作的能力，必须使用其子类。使用NSOperation⼦类的方式有3种： 系统实现的具体子类：NSInvocationOperation 系统实现的具体子类：NSBlockOperation 自定义子类,实现内部相应的⽅法该类是线程安全的，不必管理线程生命周期和同步等问题。 a. NSInvocationOperation子类 NSInvocationOperation是NSOperation的子类。创建操作对象的方式有2种，使用initWithTarget:selector:object:创建sel参数是一个或0个的操作对象。使用initWithInvocation:方法，添加sel参数是0个或多个操作对象。在未添加到队列的情况下，创建操作对象的过程中不会开辟线程，会在当前线程中执行同步操作。创建完成后，直接调用start方法，会启动操作对象来执行操，或者添加到NSOperationQueue队列中。无论使用该子类的哪个在初始化的方法，都会在添加一个任务。 和NSBlockOperation子类不同的是，因为没有额外添加任务的方法，使用NSInvocationOperation创建的对象只会有一个任务。 默认情况下，调用start方法不会开辟一个新线程去执行操作，而是在当前线程同步执行任务。只有将其放到一个NSOperationQueue中，才会异步执行操作 b. NSBlockOperation子类可以通过blockOperationWithBlock:创建NSBlockOperation对象,在创建的时候也添加一个任务。如果想添加更多的任务，可以使用addExecutionBlock:方法。也可以通过init：创建NSBlockOperation对象。但是这种创建方式并不会在创建对象的时候添加任务，同样可以使用addExecutionBlock:方法添加任务。对于启动操作和NSInvocationOperation类一样，都可以通过调用start方法和添加NSOperationQueue中来执行操作。 关于任务的的同步、异步的执行可以总结几点： 任务数为1时，即使用blockOperationWithBlock:方法或者init:与addExecutionBlock:二个方法结合的方式创建的唯一一个任务时，不会开辟新线程，直接在当前线程同步执行任务。 任务数大于1时，使用blockOperationWithBlock:方法或者init:与addExecutionBlock:二个方法结合的方式创建的一个任务A，不会开辟线程，直接在当前线程同步执行任务。而NSBlockOperation对象使用addExecutionBlock:方法添加的其他任务会开辟新线程，异步执行任务。 将操作放到一个NSOperationQueue中，会异步执行操作任务。 注意：不可在completionBlock属性的block中追加任务，因为在操作已经启动执行中或者结束后不可以添加block任务。 c. 自定义子类 一般类NSInvocationOperation、NSBlockOperation就可以满足使用需要，当然还可以自己自定义子类。 创建的子类时，需要考虑到可能会添加到串行和并发队列的不同情况，需要重写不同的方法。对于串行操作，仅仅需要重新main方法就行，在这个方法中添加想要实现的功能。对于并发操作，重写四个方法：start、asynchronous、executing、finished。并且需要自己创建自动释放池，因为异步操作无法访问主线程的自动释放池。 注意：在自定义子类时，经常通过cancelled属性检查方法是否取消，并且对取消的做出响应。 2. NSOperationQueue使用将NSOperation对象添加NSOperationQueue中，来管理操作对象是非常方便的。因为当我们把操作对象添加到NSOperationQueue对象后，该NSOperationQueue对象从线程中拿取操作、以及分配到对应线程的工作都是由系统处理的。只要是创建了队列，在队列中的操作，就会在子线程中执行，并且默认并发操作。添加到子队列NSOperationQueue实例中的操作，都是异步执行 a.操作对象添加到NSOperationQueue对象中添加的方式有3种。 addOperation:添加一个操作 addOperationWithBlock:，系统自动封装成一个NSBlockOperation对象，然后添加到队列中 addOperations:waitUntilFinished:添加多个操作操作对象添加到NSOperationQueue之后,通常短时间内就会运行。但是如果存在依赖,或者整个队列被暂停等原因,也可能需要等待。 操作对象添加NSOperationQueue中后，不要再修改操作对象的状态。因为操作对象可能会在任何时候运行,因此改变操作对象的依赖或数据会产生无法预估的问题。只能查看操作对象的状态, 比如是否正在运行、等待运行、已经完成等。 b. 设置最多并发数 不要开辟太多线程，因为开辟线程需要消耗CPU资源。一般以2~3为宜，虽然任务可以在子线程处理，但是cpu处理过多的子线程可能会让UI变卡顿。 通过maxConcurrentOperationCount属性，设置了最多并发数，就可以主动的控制开辟线程的个数了，这是NSThread和GCD都不具体的功能。当最多并发数为一，就是个串行队列了。当然这个GCD的串行队列还是有些不同的。因为约束执行顺序的还有依赖和优先级等因素。maxConcurrentOperationCount默认是-1，不可设置为0。如果没有设置最大并发数，那么并发的个数是由系统内存和CPU决定的。 虽然NSOperationQueue类设计用于并发执行操作，但是也可以强制让单个队列一次只能执行一个操作。setMaxConcurrentOperationCount:方法可以设置队列的最大并发操作数量。当设为1就表示NSOperationQueue实例每次只能执行一个NSOperation子类对象。不过操作对象执行的顺序会依赖于其它因素,比如操作是否准备好和操作对象的优先级等。因此串行化的operation queue并不等同于GCD中的串行dispatch queue。 相关概念： 并发数:同时执⾏的任务数,即队列中同时运行的线程数。eg,同时开4个线程执行4个任务,并发数就是4。 最大并发数:同一时间最多能执行的任务的个数。即队列中最多同时运行的线程数。 c. 进度修改 一个操作执行还未完成时，我们可能需要让该任务暂停、可能之后在进行某些操作后又希望继续执行。为了满足这个需要，苹果公司，为我们提供了suspended属性。当可能我们不想执行某些操作时，可以个cancel方法、cancelAllOperations方法可以取消操作对象，一旦调用了这2个方法，操作对象将无法恢复。具体如下： 对于暂停操作，当NSOperationQueue对象属性suspended设置为YES，队列会停止对任务调度。对那些还在线程中的操作有影响的。如果任务正在执行将不会受到影响，因为任务已经被队列调度到一个线程上并执行。 对于继续操作，当属性suspended设置为NO会继续执行线程操作。队列将积极启动队列中已准备执行的操作。 一旦NSOperation子类操作对象添加到NSOperationQueue对象中,该队列就拥有了该操作对象并且不能删除操作对象,如果不想执行操作对象，只能取消该操作对象。关于取消操作，可以分为2种情况，取消一个操作和取消一个队列的全部操作二种情况。调用NSOperation类实例的cancel方法取消单个操作对象。调用NSOperationQueue类实例cancelAllOperations方法取消队列中全部操作对象。 对于队列中的操作，只有操作标记为已结束才能被队列移除。在队列中未被调度的操作，会调用start方法执行操作，以便操作对象处理取消事件。然后标记这些操作对象为已结束。对于正在线程中执行其任务的操作对象，正在执行的任务会继续执行，该操作对象会被标记经结束。注意：只会停止调度队列中操作对象，正在执行任务的依然会执行，且取消不可恢复。 d.作用 NSOperation对象可以调⽤start⽅法来执⾏任务,但默认是同步执行的（可以创建异步操作，NSBlockOperation添加操作数大于1时，除第一个任务外，其任务就是异步执行）。如果将NSOperation添加到NSOperationQueue中，之后操作就就由系统管理，系统先从队列中取出操作，然后放到一个新线程中异步执行。总结:添加操作到NSOperationQueue中，自动执行操作，自动开启线程 f. 获取队列 系统提供了2个，可以获取当前队列和主队列。可以通过类属性currentQueue获取当前队列。可以通过类属性mainQueue获取主队列. 3.依赖 操作对象可以添加和移除依赖。当一个操作对象添加了依赖，被依赖的操作对象就会先执行，当被依赖的操作对象执行完才会当前的操作对象。添加到不同线程对象中的操作对象依然彼此间可以单方面依赖。切记循环依赖的情况。这样会产生死循环。 可以通过addDependency方法添加一个或者多个依赖的对象。eg:[A addDependency:B]; 操作A依赖于操作B。操作对象会管理自己的依赖，因此在不相同队列中的操作对象可以建立依赖关系。但是一定要在添加线程对象NSOperationQueue之前，进行依赖设置。设置依赖可以保证执行顺序，操作添加到队列添加的顺序并不能决定执行顺序，执行的顺序取决于多种因素比如依赖、优先级等。 调用removeDependency:方法移除依赖。 如图，箭头方向就是依赖的对象，从图中可知，A依赖b，而b依赖C。所以三者的执行顺序是C–&gt;b–&gt;A 4.线程安全在NSOperation实例在多线程上执行是安全的，不需要添加额外的锁 5.cancel方法 只会对未执行的操作有效，正在执行的操作，在收到cancel消息后，依然会执行。 调用操作队列中的操作的cancel方法，且该操作队列具有未完成的依赖操作时，那么这些依赖操作会被忽略。由于操作已经被取消，因此此行为允许队列调用操作的start方法，以便在不调用其主方法的情况下从队列中删除操作。如果对不在队列中的操作调用cancel方法，则该操作立即标记为已取消。 6.状态属性 一个线程有未创建、就绪、运行中、阻塞、消亡等多个状态。而操作对象也有多种状态：executing(执行中)、finished(完成)、ready(就绪)状态，这三个属性是苹果公司，提供给我们用于观察操作对象状态的时候用的。因为这个三个属性KVC与KVO兼容的,因此可以监听操作对象状态属性。 7.操作完成a. 监听操作完成当我们可能需要在某个操作对象完成后添加一些功能，此时就可以用属性completionBlock来添加额外的内容了。123operation.completionBlock = ^&#123; // 完成操作后，可以追加的内容&#125;; b. 等待操作完成这个有2种情况：一是等待单个操作对象，而是等待队列里全部的操作。 如果想等待整个队列的操作，可以同时等待一个queue中的所有操作。使用NSOperationQueue的waitUntilAllOperationsAreFinished方法。在等待一个队列时,应用的其它线程仍然可以往队列中添加操作,因此可能会加长线程的等待时间。12// 阻塞当前线程，等待queue的所有操作执行完毕[queue waitUntilAllOperationsAreFinished]; 对于单个操作对象，为了最佳的性能,尽可能设计异步操作,这样可以让应用在正在执行操作时可以去处理其它事情。如果需要当前线程操作对象处理完成后的结果,可以使用NSOperation的waitUntilFinished方法阻塞当前线程，等待操作完成。通常应该避免这样编写,阻塞当前线程可能是一种简便的解决方案,但是它引入了更多的串行代码,限制了整个应用的并发性,同时也降低了用户体验。绝对不要在应用主线程中等待一个Operation,只能在非中等待。因为阻塞主线程将导致应用无法响应用户事件,应用也将表现为无响应。12// 会阻塞当前线程，等到某个operation执行完毕[operation waitUntilFinished]; 8.执行顺序添加到NSOperationQueue中的操作对象，其执行顺序取决于2点：1.首先判断操作对象是否已经准备好：由对象的依赖关系确定2.然后再根据所有操作对象的相对优先级来确定：优先级等级则是操作对象本身的一个属性。默认所有操作对象都拥有“普通”优先级,不过可以通过qualityOfService:方法来提升或降低操作对象的优先级。优先级只能应用于相同队列中的操作对象。如果应用有多个操作队列,每个队列的优先级等级是互相独立的。因此不同队列中的低优先级操作仍然可能比高优先级操作更早执行。 对于优先级，我们可以使用属性queuePriority给某个操作对象设置高底，优先级高的任务，调用的几率会更大, 并不能保证执行顺序。并且优先级不能替代依赖关系,优先级只是对已经准备好的操作对象确定执行顺序。先满足依赖关系,然后再根据优先级从所有准备好的操作中选择优先级最高的那个执行。 9.服务质量 根据CPU，网络和磁盘的分配来创建一个操作的系统优先级。一个高质量的服务就意味着更多的资源得以提供来更快的完成操作。涉及到CPU调度的优先级、IO优先级、任务运行所在的线程以及运行的顺序等等 通过设置属性qualityOfService来设置服务质量。QoS 有五种优先级，默认为NSQualityOfServiceDefault。它的出现统一了Cocoa中所有多线程技术的优先级。在此之前，NSOperation和NSThread都通过threadPriority来指定优先级，而 GCD 则是根据 DISPATCH_QUEUE_PRIORITY_DEFAULT 等宏定义的整形数来指定优先级。正确的使用新的 QoS 来指定线程或任务优先级可以让 iOS 更加智能的分配硬件资源，以便于提高执行效率和控制电量。 三、相关类介绍NSOperationNSOperation是NSObject的子类，表示单个工作单元。它是一个与任务的相关抽象类，为状态、优先级、依赖关系和管理提供了一个有用的、线程安全的结构。 创建自定义NSOperation子类是没有意义的，Foundation提供了具体的实现的子类：NSBlockOperation和NSInvocationOperation。 适合于NSOperation的任务的例子包括网络请求、图像调整、文本处理或任何其他可重复的、结构化的、长时间运行的任务，这些任务会产生关联的状态或数据。 概观 因为NSOperation类是一个抽象类，并不具备封装操作的能力，所以不能直接使用该类，而是应该使用其子类来执行实际的任务。其子类包括2种，系统定义的子类(NSInvocationOperation或NSBlockOperation)和自定义的子类。虽然NSOperation类是抽象类，但是该类的基本实现中包括了安全执行任务的重要逻辑。这个内置逻辑的存在可以让你专注于任务的实际实现,而不是专注于编写能保证它与其他系统对象的正常工作的粘合代码。 一个操作对象是一个单发对象,也就是说，一旦它执行了其任务,将不能再执行一遍。通常通过添加他们到一个操作队列(NSOperationQueue类的一个实例)中来执行操作。操作队列通过让操作在辅助线程(非主线程)上运行,或间接使用libdispatch库(也称为GCD)直接来执行其操作。 如果不想使用一个操作队列,可以调用start方法直接来执行一个操作。手动执行操作会增加更多的代码负担,因为开启不在就绪状态的操作会引发异常。ready属性表示操作的就绪状态。 操作依赖 依赖是一种按照特定顺序执行操作的便捷方式。可以使用addDependency:、removeDependency:方法给操作添加和删除依赖。默认情况下,直到具有依赖的操作对象的所有依赖都执行完成才会认为操作对象是ready(就绪)状态，。一旦最后一个依赖操作完成,这个操作对象会变成就绪状态并且可以执行。 NSOperation支持的依赖是不会区分其操作是成功的完成还是失败的完成。(换句话说,取消操作也视为完成。)由你来决定有依赖的操作在其所依赖的操作被取消或没有成功完成任务的情况下是否应该继续。这可能需要合并一些额外的错误跟踪功能到操作对象里。 兼容KVO的属性NSOperation类对其一些属性是键值编码(KVC)和键值观察(KVO)兼容的。如有需要,可以观察这些属性来控制应用程序的其他部分。使用以下键路径来观察属性： isCancelled - 只读 isAsynchronous - 只读 isExecuting - 只读 isFinished - 只读 isReady - 只读 dependencies - 只读 queuePriority - 读写 completionBlock - 读写 虽然可以为这些属性添加观察者,但是不应该使用Cocoa bindings来把它们和用户界面相关的元素绑定。用户界面相关的代码通常只有在应用程序的主线程中执行。因为一个操作可以在任何线程上执行,该操作KVO通知同样可能发生在任何线程。 如果你为之前的属性提供了自定义的实现,那么该实现内容必须保持与KVC和KVO的兼容。如果你为NSOperation对象定义了额外的属性,建议你同样需要让这些属性保持KVC和KVO兼容。 多核注意事项 可以从多线程中安全地调用NSOperation对象的方法而不需要创建额外的锁来同步存取对象。这种行为是必要的,因为一个操作的创建和监控通常在一个单独的线程上。 当子类化NSOperation类时,必须确保任何重写的方法能在多个线程中是安全的调用。如果实现子类中自定义方法,比如自定义数据访问器(accessors，getter),必须确保这些方法是线程安全的。因此,访问任何数据变量的操作必须同步,以防止潜在的数据损坏。更多关于信息同步的，可以查看Threading Programming Guide。 异步操作 VS 同步操作 如果想要手动执行操作对象而不是将其添加到一个队列中,那么可以设计同步或异步的二种方式来执行操作。操作对象默认是同步的。在同步操作中,操作对象不会创建一个单独的线程来运行它的任务。当直接调用同步操作的start方法时,该操作会在当前线程中立即执行。等到这个对象的开始(start)方法返回给调用者时，表示该任务完成。 当你调用一个异步操作的start方法时,该方法可能在相应的任务完成前返回。一个异步操作对象负责在一个单独线程上调度任务。通过直接开启新一个线程、调用一个异步方法,或者提交一个block到调度队列来执行这个操作。一个异步操作对象可以直接启动一个新线程。(具有开辟新线程的能力，但是不一定就好开启新线程，因为CPU资源有限，不可能开启无限个线程) 如果使用队列来执行操作,将他们定义为同步操作是非常简单的。如果手动执行操作,可以将操作对象定义为异步的。定义一个异步操作需要更多的工作,因为你必须监控正在进行的任务的状态和使用报告KVO通知状态的变化。但在你想确保手动执行操作不会阻塞调用线程的情况下定义异步操作是特别有用的。 当添加一个操作到一个操作队列中,队列中操作会忽略了asynchronous属性的值,总是从一个单独的线程调用start方法。因此,如果你总是通过把操作添加到操作队列来运行操作,没有理由让他们异步的。 子类化注释 NSOperation类提供了基本的逻辑来跟踪操作的执行状态,但必须从它派生出子类做实际工作。如何创建子类依赖于该子类设计用于并发还是非并发。 方法的重载对于非并发操作,通常只覆盖一个方法 main 在该方法中,需要给执行特定的任务添加必要的代码。当然,也可以定义一个自定义的初始化方法,让它更容易创建自定义类的实例。你可能还想定义getter和setter方法来从操作访问数据。然而,如果你定义定制了getter和setter方法,你必须确保这些方法在多个线程调用是安全的。 如果你创建一个并发操作,需要至少重写下面的方法和属性: start asynchronous executing finished 在并发操作中,start方法负责以异步的方式启动操作。从这个方法决定否生成一个线程或者调用异步函数。在将要开始操作时,start方法也应该更新操作executing属性的执行状态作为报告。这可以通过发送executing这个键路径的KVO通知,让感兴趣的客户端知道该操作现在正在运行中。executing属性还必须以线程安全的方式提供状态。 在将要完成或取消任务时,并发操作对象必须生成isExecuting和isFinished键路径的KVO通知为来标记操作的最终改变状态。(在取消的情况下,更新isFinished键路径仍然是重要的,即使操作没有完全完成其任务。已经排队的操作必须在队列删除操作前报告)除了生成KVO通知,executing和finished属性的重写还应该继续根据操作的状态的精确值来报告。 重要：在start方法中，任何时候都不应该调用super。当定义一个并发操作时，需要自己提供与默认start方法相同的行为，包括启动任务和生成适当的KVO通知。start方法还应该在实际开始任务之前检查操作本身是否被取消。 对于并发操作，除了上面描述的方法之外，应该不需要重写其他方法。然而，如果你自定义操作的依赖特性，可能必须重写额外的方法并提供额外的KVO通知。对于依赖项，这可能只需要提供isReady键路径的通知。因为dependencies属性包含了一系列依赖操作，所以对它的更改已经由默认的NSOperation类处理。 维护操作对象状态操作对象通过维护内容的状态信息来决定何时执行是安全的和在操作的生命周期期间通知外部其任务进展。自定义子类需要维护状态信息来保证代码中执行操作的正确性。操作状态关联的键路径有： isReady 该键路径让客户端知道一个操作何时可以准备执行。当操作马上可以执行时该属性值为true，当其依赖中有未完成，则是false。大多数情况下，没必要自己管理这个键路径的状态。如果操作的就绪状态是由操作依赖因素决定(例如在你的程序中的一些外部条件)，那么你可以提供ready属性的实现并且跟踪操作的就绪状态。虽然只在外部状态允许的情况下创建操作对象时通常更简单。 在macOS 10.6或更高版本中，如果取消的操作，正在等待一个或多个依赖操作完成，那么这些依赖项将被忽略，该属性的值将更新成已经准备好运行了。这种行为使操作队列有机会更快地将已取消的操作从队列中清除出去。 isExecuting 该键路径让客户端知道操作是否在正在地执行它所分配的任务。如果操作正在处理其任务，则值为true;否则值为false。 如果替换操作对象的start方法，则还必须替换executing属性，并在操作的执行状态发生变化时生成KVO通知。 isFinished 该键路径让客户端知道操作成功地完成了任务或者被取消并退出。直到isFinished这个键路径的值变为true，操作对象才会清除依赖。类似的，直到finished属性的是true时，一个操作队列才会退出操作队列。因此，将操作标记为已完成对于防止队列备份正在进行的操作或已取消的操作非常重要。 如果替换操作对象的start方法，则还必须替换executing属性，并在操作的执行状态发生变化时生成KVO通知。 isCancelled isCancelled键路径让客户端知道请求取消某个操作。支持自愿取消，但不鼓励主动发送这个键路径的KVO通知。 响应取消命令一旦将操作添加到队列中，操作就不在你的控制范围内了。队列接管并处理该任务的调度。但是，如果你最终决定不想执行某些操作，例如用户按下取消按钮或退出应用程序时，你可以取消操作，以防止消耗不必要地CPU时间。可以通过调用操作对象本身的cancel方法或调用NSOperationQueue类的cancelAllOperations方法来实现这一点。 取消一个操作不会立即迫使它停止它正在做的事情。虽然所有操作都需要考虑cancelled属性中的值，但是必须显式检查该属性中的值，并根据需要中止。NSOperation的默认实现包括取消检查。例如，如果在调用一个操作的start方法之前取消该操作，那么start方法将退出而不启动任务。 提示 在macOS 10.6或更高版本中，如果调用操作队列中的操作的cancel方法，且该操作队列具有未完成的依赖操作，那么这些依赖操作随后将被忽略。由于操作已经被取消，因此此行为允许队列调用操作的start方法，以便在不调用其主方法的情况下从队列中删除操作。如果对不在队列中的操作调用cancel方法，则该操作立即标记为已取消。在每种情况下，将操作标记为已准备好或已完成时，会生成适当的KVO通知。 在你编写的任何定制代码中，都应该始终支持取消语义。特别是，主任务代码应该定期检查cancelled属性的值。如果属性值为YES，则操作对象应该尽快清理并退出。如果您实现了一个自定义的start方法，那么该方法应该包含早期的取消检查并适当地执行。您的自定义开始方法必须准备好处理这种类型的提前取消。 除了在操作被取消时简单地退出之外，将已取消的操作移动到适当的最终状态也很重要。具体来说，如果您自己管理finished和executing属性的值(可能是因为你正在实现并发操作)，那么你必须更新更新相应地属性。具体来说，你必须将finished返回的值更改为YES，将executing返回的值更改为NO。即使操作在开始执行之前被取消，你也必须进行这些更改。 属性和方法初始化12// 返回一个初始化的NSOperation对象- (instancetype)init;// 父类 NSObject方法 执行操作12345678// 开启操作//在当前任务状态和依赖关系合适的情况下，启动NSOperation的main方法任务，需要注意缺省实现只是在当前线程运行。如果需要并发执行，子类必须重写这个方法，并且使属性asynchronous返回YES。- (void)start;// 执行接收者(NSOperation)的非并发任务。操作任务的入口，一般用于自定义NSOperation的子类- (void)main;// 操作主任务完成后执行这个block// 由于NSOperation有可能被取消，所以在block运行的代码应该和NSOperation的核心任务无关@property (nullable, copy) void (^completionBlock)(void); 取消操作123// 通知操作对象(NSOperation)停止执行其任务。标记isCancelled状态。// 调用后不会自动马上取消，需要通过isCancelled方法检查是否被取消，然后自己编写代码退出当前的操作- (void)cancel; 获取操作状态123456789101112// Boolean 值，表示操作是否已经取消@property (readonly, getter=isCancelled) BOOL cancelled;// Boolean 值，表示操作是否正在执行@property (readonly, getter=isExecuting) BOOL executing;// Boolean 值，表示操作是否正完成执行@property (readonly, getter=isFinished) BOOL finished;// Boolean 值，表示操作是否异步执行任务@property (readonly, getter=isAsynchronous) BOOL asynchronous ;// Boolean 值，表示操作是否可以立即执行(准备完毕状态)@property (readonly, getter=isReady) BOOL ready;// 操作的名字@property (nullable, copy) NSString *name; 管理依赖12345678910// 添加依赖，使接收器依赖于指定完成操作。// 如：[op1 addDependency:op2]; op2先执行，op1后执行- (void)addDependency:(NSOperation *)op;// 取消依赖，移出接收方对指定操作的依赖// 注意：操作对象的依赖不能在操作队列执行时取消- (void)removeDependency:(NSOperation *)op;// 在当前对象开始执行之前必须完成执行的操作对象数组。@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 执行优先级12// 操作获取系统资源的相对的重要性。系统自动合理的管理队列的资源分配@property NSQualityOfService qualityOfService; 等待一个操作对象12// 阻塞当前线程的执行，直到操作对象完成其任务。可用于线程执行顺序的同步。- (void)waitUntilFinished; 常量1234// 这些常量允许您对执行操作的顺序进行优先排序。NSOperationQueuePriority// 用于表示工作对系统的性质和重要性。服务质量较高的类比服务质量较低的类获得更多的资源。NSQualityOfService 12345678// NSOperation优先级的枚举typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123; NSOperationQueuePriorityVeryLow = -8L, NSOperationQueuePriorityLow = -4L, NSOperationQueuePriorityNormal = 0, NSOperationQueuePriorityHigh = 4, NSOperationQueuePriorityVeryHigh = 8&#125;; 在iOS8之后苹果提供了几个Quality of Service枚举来使用：user interactive, user initiated, utility 和 background。通过这些枚举告诉系统我们在进行什么样的工作，然后系统会通过合理的资源控制来最高效的执行任务代码，其中主要涉及到CPU调度的优先级、IO优先级、任务运行在哪个线程以及运行的顺序等等，我们可以通过一个抽象的Quality of Service枚举参数来表明任务的意图以及类别 12345678910//与用户交互的任务，这些任务通常跟UI级别的刷新相关，比如动画，这些任务需要在一瞬间完成.NSQualityOfServiceUserInteractive// 由用户发起的并且需要立即得到结果的任务，比如滑动scroll view时去加载数据用于后续cell的显示，这些任务通常跟后续的用户交互相关，在几秒或者更短的时间内完成NSQualityOfServiceUserInitiated// 一些可能需要花点时间的任务，这些任务不需要马上返回结果，比如下载的任务，这些任务可能花费几秒或者几分钟的时间NSQualityOfServiceUtility// 一些可能需要花点时间的任务，这些任务不需要马上返回结果，比如下载的任务，这些任务可能花费几秒或者几分钟的时间NSQualityOfServiceBackground// 一些可能需要花点时间的任务，这些任务不需要马上返回结果，比如下载的任务，这些任务可能花费几秒或者几分钟的时间NSQualityOfServiceDefault eg:Utility 及以下的优先级会受到 iOS9 中低电量模式的控制。另外，在没有用户操作时，90% 任务的优先级都应该在 Utility 之下。 NSBlockOperationNSOperation的子类，管理一个或多个块的并发执行的操作。 概观NSBlockOperation类是NSOperation的一个具体子类，它管理一个或多个块的并发执行。可以使用此对象一次执行多个块，而不必为每个块创建单独的操作对象。当执行多个块时，只有当所有块都完成执行时，才认为操作本身已经完成。 添加到操作中的块(block)将以默认优先级分配到适当的工作队列。 方法属性管理操作中的块123456// 创建并返回一个NSBlockOperation对象，并添加指定的块到该对象中。+ (instancetype)blockOperationWithBlock:(void (^)(void))block;// 将指定的块添加到要执行的块列表中。- (void)addExecutionBlock:(void (^)(void))block;// 与接收器关联的块。@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks; NSInvocationOperationNSOperation的子类,管理作为调用指定的单个封装任务执行的操作。 概观NSInvocationOperation类是NSOperation的一个具体子类，可以使用它来初始化一个包含在指定对象上调用选择器的操作。这个类实现了一个非并发操作。 方法属性初始化1234// 返回一个用指定的目标和选择器初始化的NSInvocationOperation对象。- (instancetype)initWithTarget:(id)target selector:(SEL)sel object:(nullable id)arg;// 返回用指定的调用对象初始化的NSInvocationOperation对象。- (instancetype)initWithInvocation:(NSInvocation *)inv NS_DESIGNATED_INITIALIZER; 获取属性1234// 接收者的调用对象。@property (readonly, retain) NSInvocation *invocation;// 调用或方法的结果@property (nullable, readonly, retain) id result; 常量12// 如果调用result方法时出现错误，则由NSInvocationOperation引发的异常名称。Result Exceptions NSOperationQueue管理操作执行的队列。 概观NSObject子类。操作队列根据其优先级和就绪程度执行其排队的NSOperation对象。在添加到操作队列后，操作将保持在其队列中，直到它报告其任务结束为止。在队列被添加后，您不能直接从队列中删除操作。 提示：操作队列保留操作直到完成，队列本身保留到所有操作完成。使用未完成的操作挂起操作队列可能导致内存泄漏。 确定执行顺序队列中的操作是根据它们的状态、优先级和依赖关系来组织的，并相应地执行。如果所有排队的操作都具有相同的queuePriority并准备好在放入队列时执行(也就是说，它们的就绪属性返回yes)，那么它们将按照提交到队列的顺序执行。否则，操作队列总是执行优先级最高的操作。 但是不应该依赖队列语义来确保操作的特定执行顺序，因为操作准备状态的更改可能会更改最终的执行顺序。操作间依赖关系为操作提供了绝对的执行顺序，即使这些操作位于不同的操作队列中。一个操作对象直到它的所有依赖操作都完成执行后才被认为准备好执行。 取消操作结束任务并不一定意味着操作完成了任务，一个操作也可以被取消。取消操作对象会将该对象留在队列中，但会通知该对象应该尽快停止其任务。对于当前正在执行的操作，这意味着操作对象必须检查取消状态，停止它正在执行的操作，并将自己标记为已结束。对于在队列排队但尚未执行的操作，队列仍然需要调用操作对象的start方法，以便它能够处理取消事件并将自己标记为已结束。 提示取消操作会导致操作忽略它可能具有的依赖项。这种行为使队列能够尽快执行操作的start方法。开始方法依次将操作移动到结束状态，以便可以将其从队列中删除。 KVO兼容属性NSOperationQueue类是符合键值编码(KVC)和键值观察(KVO)的。可以根据需要观察这些属性，以控制应用程序的其他部分。要观察属性，使用以下键路径: operations - 只读 operationCount - 只读 maxConcurrentOperationCount - 读写 suspended - 读写 name - 读写 虽然可以将观察者附加到这些属性，但是不应该使用Cocoa bindings(绑定)将它们绑定到用户界面的相关的元素。与用户界面关联的任务通常只能在应用程序的主线程中执行。然而与操作队列相关联的KVO通知可能发生在任何线程中。 线程安全从多个线程中使用一个NSOperationQueue对象是安全的，无需创建额外的锁来同步对该对象的访问。 操作队列使用调度框架来启动其操作的执行。因此，操作总是在单独的线程上执行，而不管它们是被指定为同步的还是异步的。 属性&amp;方法访问特定操作队列1234// 返回与主线程关联的操作队列。缺省总是有一个queue。@property (class, readonly, strong) NSOperationQueue *mainQueue;// 返回启动当前操作的操作队列。@property (class, readonly, strong, nullable) NSOperationQueue *currentQueue; 管理队列中的操作1234567891011121314// 将指定的操作添加到接收器。- (void)addOperation:(NSOperation *)op;//将指定的操作添加到队列。- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait;// 在操作中包装指定的块并将其添加到接收器。- (void)addOperationWithBlock:(void (^)(void))block;// 当前在队列中的操作。@property (readonly, copy) NSArray&lt;__kindof NSOperation *&gt; *operations;// 队列中当前的操作数。@property (readonly) NSUInteger operationCount;// 取消所有排队和执行的操作。- (void)cancelAllOperations;// 阻塞当前线程，直到所有接收者的排队操作和执行操作完成为止- (void)waitUntilAllOperationsAreFinished; 管理操作的执行123456// 应用于使用队列执行的操作的默认服务级别。@property NSQualityOfService qualityOfService;// 可以同时执行的队列操作的最大数量。@property NSInteger maxConcurrentOperationCount;// 在队列中并发执行的默认最大操作数。NSOperationQueueDefaultMaxConcurrentOperationCount 暂停执行12// 一个布尔值，表示队列是否在主动调度要执行的操作。(suspended 挂起，暂停的)@property (getter=isSuspended) BOOL suspended; 当该属性的值为NO时，队列将积极启动队列中已准备执行的操作。将此属性设置为YES时，可以防止队列启动任何排队着的操作，但是已经执行的操作将继续执行。可以继续将操作添加到已挂起的队列中，但在将此属性更改为NO之前，这些操作不会安排执行。操作只有在结束执行后才从队列中删除。但是，为了结束执行，必须首先启动一个操作。因为挂起的队列不会启动任何新操作，所以它不会删除当前排队但未执行的任何操作(包括已取消的操作)。 可以使用键值观察监视此属性值的更改。配置一个观察者来监视操作队列的suspended键路径。此属性的默认值是NO。 队列配置1234// 操作队列名称@property (nullable, copy) NSString *name;// 用于执行操作的调度队列。@property (nullable, assign /* actually retain */) dispatch_queue_t underlyingQueue; 四、使用1. NSInvocationOperation创建：调用Start方法开启。默认情况下，调用start方法不会开辟一个新线程去执行操作，而是在当前线程同步执行操作。 创建方式一：使用initWithInvocation方法，可以设置0个或多个参数12345678910NSMethodSignature *sig = [[self class] instanceMethodSignatureForSelector:@selector(addSig:)];NSInvocation *invo = [NSInvocation invocationWithMethodSignature:sig];NSString * info = @&quot;NSMethodSignature&quot;;[invo setTarget:self];[invo setSelector:@selector(addSig:)]; //argumentLocation 指定参数，以指针方式 // idx 参数索引，第一个参数的起始index是2，因为index为1，2的分别是self和selector[invo setArgument:(__bridge void *)(info) atIndex:2];NSInvocationOperation *invocationOp = [[NSInvocationOperation alloc] initWithInvocation:invo];[invocationOp start]; 创建方式二：使用initWithTarget1234// 初始化NSInvocationOperation *invocationOp = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOpSel:) object:@&quot;111&quot;]; // 操作的第一个// 执行[invocationOp start]; 2. NSBlockOperation创建第一个操作任务，一般不会开辟新线程，就在当前线程中执行。之后的任务都是开辟新线程。执行异步任务。 创建方式一：使用init:创建操作对象，然后使用addExecutionBlock:添加执行123456789101112131415161718NSBlockOperation * op1 = [[NSBlockOperation alloc] init]; [op1 addExecutionBlock:^&#123; NSLog(@&quot;1 beign&quot;); NSLog(@&quot;1--%@&quot;,[NSThread currentThread]); NSLog(@&quot;1 end&quot;); &#125;]; [op addExecutionBlock:^&#123; NSLog(@&quot;2 beign&quot;); NSLog(@&quot;2--%@,currentQueue &gt;&gt;&gt;&gt; %@&quot;,[NSThread currentThread],[NSOperationQueue currentQueue]); NSLog(@&quot;2 end&quot;); &#125;]; [op addExecutionBlock:^&#123; NSLog(@&quot;3 beign&quot;); NSLog(@&quot;3--%@,currentQueue &gt;&gt;&gt;&gt; %@&quot;,[NSThread currentThread],[NSOperationQueue currentQueue]); NSLog(@&quot;3 end&quot;); &#125;]; [op1 start]; 创建方式二：使用blockOperationWithBlock创建操作对象12345678910111213141516171819NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;1 beign&quot;); NSLog(@&quot;1--%@,currentQueue &gt;&gt;&gt;&gt; %@&quot;,[NSThread currentThread],[NSOperationQueue currentQueue]); // 第一个操作任务，一般不会开辟新线程。就在当前线程中执行 NSLog(@&quot;1 end&quot;); &#125;]; // 以下操作任务，会开辟新线程 [op addExecutionBlock:^&#123; NSLog(@&quot;2 beign&quot;); NSLog(@&quot;2--%@,currentQueue &gt;&gt;&gt;&gt; %@&quot;,[NSThread currentThread],[NSOperationQueue currentQueue]); NSLog(@&quot;2 end&quot;); &#125;]; [op addExecutionBlock:^&#123; NSLog(@&quot;3 beign&quot;); NSLog(@&quot;3--%@,currentQueue &gt;&gt;&gt;&gt; %@&quot;,[NSThread currentThread],[NSOperationQueue currentQueue]); NSLog(@&quot;3 end&quot;); &#125;]; [op start]; 3. NSOperationQueue3.1. 将操作对象添加到队列中1234567NSOperationQueue *queue = [[NSOperationQueue alloc] init];NSBlockOperation *blockOp = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;1 beign&quot;); NSLog(@&quot;1--%@&quot;,[NSThread currentThread]); NSLog(@&quot;1 end&quot;);&#125;];[queue addOperation:blockOp]; 3.2. 添加依赖 直接使用start启动一个操作对象而非将操作对象添加到NSOperationQueue对象中是没有意义的。因为当给操作对象发送start消息后，启动操作，如果线程未阻塞会立即执行该任务。所以就没有所谓的执行顺序。只有将操作对象添加到NSOperationQueue对象中，在队列调度的时候，可以按照依赖、优先级等因素顺序的调度任务。 注意：一定要在添加线程对象NSOperationQueue之前，进行依赖设置。否则依赖将无法达到预期效果。 a. 通队列之间的依赖1234567891011// 创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 创建操作 NSInvocationOperation *invocationOp = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOpSel:) object:@&quot;invocationOp--arg&quot;]; NSInvocationOperation *invocationOp2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOp2Sel:) object:@&quot;invocationOp2--arg&quot;]; // 设置依赖，操作invocationOp2的任务执行完，才会执行操作invocationOp的任务。 [invocationOp addDependency:invocationOp2]; // 执行 [queue addOperation:invocationOp]; [queue addOperation:invocationOp2]; b. 不同队列间的依赖1234567891011121314151617181920212223242526272829303132333435363738// 创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 创建操作NSBlockOperation *block1Op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;block1Op -- begin&quot;); [NSThread sleepForTimeInterval:3]; // 模拟耗时操作 NSLog(@&quot;block1Op -- end&quot;);&#125;];NSBlockOperation *block2Op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;block2Op -- begin&quot;); [NSThread sleepForTimeInterval:4]; // 模拟耗时操作 NSLog(@&quot;block2Op -- end&quot;);&#125;];// 创建队列NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];// 创建操作NSBlockOperation *block3Op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;block3Op -- begin&quot;); [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;block3Op -- end&quot;);&#125;];NSBlockOperation *block4Op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;block4Op -- begin&quot;); [NSThread sleepForTimeInterval:1]; // 模拟耗时操作 NSLog(@&quot;block4Op -- end&quot;);&#125;];// 设置依赖，操作invocationOp2的任务执行完，才会执行操作invocationOp的任务。[block1Op addDependency:block3Op];[block3Op addDependency:block2Op];// block2Op --&gt; block3Op --&gt; block1Op// 添加操作到队列中[queue addOperation:block1Op];[queue addOperation:block2Op];[queue2 addOperation:block3Op];[queue2 addOperation:block4Op]; 从上代码可以得到block1Op、block2Op、block3Op三个操作的执行顺序：block2Op –&gt; block3Op –&gt; block1Op。123456789101112131415// 创建操作NSBlockOperation *blockOp = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;blockOp&quot;); // 模拟耗时操作 [NSThread sleepForTimeInterval:3];&#125;];NSBlockOperation *block2Op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;block2Op -- begin&quot;); // 等blockOp操作对象的任务执行完，才能接着往下执行 [blockOp waitUntilFinished]; NSLog(@&quot;block2Op --end&quot;);&#125;];// 执行[queue addOperation:blockOp];[queue addOperation:block2Op]; 3.3. 获取属性获取主队列1NSOperationQueue *queue = [NSOperationQueue mainQueue]; 3.4. 获取属性获取当前队列1NSOperationQueue *queue = [NSOperationQueue currentQueue]; 3.5. 进度修改：NSOperationQueue队列的暂停、继续和取消。1234567891011121314151617181920212223242526272829303132333435363738// 初始化队列- (NSOperationQueue *)manualQueue&#123; if (!_manualQueue) &#123; _manualQueue = [NSOperationQueue new]; _manualQueue.maxConcurrentOperationCount = 2; &#125; return _manualQueue;&#125;NSBlockOperation *blockOperation1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;1--start&quot;); [NSThread sleepForTimeInterval:3]; NSLog(@&quot;1--end&quot;); &#125;]; NSBlockOperation *blockOperation2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;2--start&quot;); [NSThread sleepForTimeInterval:1]; NSLog(@&quot;2--end&quot;); &#125;]; NSBlockOperation *blockOperation3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;3--start&quot;); [NSThread sleepForTimeInterval:4]; NSLog(@&quot;3--end&quot;); &#125;]; NSBlockOperation *blockOperation4 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;4--start&quot;); [NSThread sleepForTimeInterval:3]; NSLog(@&quot;4--end&quot;); &#125;]; [self.manualQueue addOperation:blockOperation1]; [self.manualQueue addOperation:blockOperation2]; [self.manualQueue addOperation:blockOperation3]; [self.manualQueue addOperation:blockOperation4]; a. 暂停 如果任务正在执行将不会受到影响。因为任务已经被队列调度到一个线程上并执行。当NSOperationQueue对象属性suspended设置为YES，是队列停止了对任务调度。对那些还在线程中的操作有影响的。1self.manualQueue.suspended = YES; b. 继续 队列将积极启动队列中已准备执行的操作。1self.manualQueue.suspended = NO; c. 取消 对于队列中的操作，只有操作标记为已结束才能被队列移除。 在队列中未被调度的操作，会调用start方法执行操作，以便操作对象处理取消事件。然后标记这些操作对象为已结束。 对于正在线程中执行其任务的操作对象，正在执行的任务会继续执行，该操作对象会被标记经结束。1[self.manualQueue cancelAllOperations]; 3.6. 操作完成 a. 监听操作完成 可以在操作执行完成后，添加额外的内容。使用属性completionBlock，可以为NSOperation对象的任务完成后添加额外的操作。但是不可在completionBlock中追加任务，因为操作(operation)已经启动执行或者结束后不可以添加block任务。 1234567NSBlockOperation *blockOperation1 = [NSBlockOperation blockOperationWithBlock:^&#123; // 添加的任务&#125;];blockOperation1.completionBlock = ^&#123; // 添加额外的内容&#125;;[blockOperation1 start]; b. 监听操作完成当执行到某个操作对象发送了一个消息waitUntilFinished:消息。当前线程会被阻塞，之前发送消息的操作对象的任务执行完毕。当前线程才会被唤起，进入准备状态，开始执行相应的任务。1234567891011121314// 创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 创建操作 NSBlockOperation *blockOp = [NSBlockOperation blockOperationWithBlock:^&#123; [NSThread sleepForTimeInterval:3]; // 模拟耗时操作 &#125;]; NSBlockOperation *block2Op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;block2Op -- begin&quot;); [blockOp waitUntilFinished]; // 等blockOp操作对象的任务执行完，才能接着往下执行 NSLog(@&quot;block2Op --end&quot;); &#125;]; // 执行 [queue addOperation:blockOp]; [queue addOperation:block2Op]; 3.7. 最大并发量 NSOperationQueue是并发队列，maxConcurrentOperationCount表示最大的并发数。当maxConcurrentOperationCount是1时，虽然NSOperationQueue对象是并发，但是线程依然是同步执行任务。但是和GCD同步不同的是，依赖和优先级因素会影响NSOperationQueue对象调度任务的顺序。添加任务顺序不一定是执行顺序。123456789101112131415161718// 创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 创建操作NSBlockOperation *block1Op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;block1Op -- begin&quot;); [NSThread sleepForTimeInterval:3]; // 模拟耗时操作 NSLog(@&quot;block1Op -- end&quot;);&#125;];NSBlockOperation *block2Op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;block2Op -- begin&quot;); [NSThread sleepForTimeInterval:4]; // 模拟耗时操作 NSLog(@&quot;block2Op -- end&quot;);&#125;];queue.maxConcurrentOperationCount = 1; // 最大并发个数[block1Op addDependency:block2Op];// 添加依赖// block2Op.queuePriority = NSOperationQueuePriorityHigh ;[queue addOperation:block1Op];[queue addOperation:block2Op]; 五、自定义NSOperation子类我们可以定义串行和并发的2种类型的NSOperation子类。 相关概念 串行(非并发)的情况 常见使用场景：和网络相关，比如图片下载 使用步骤 实现init方法，初始化操作对象以及一些其他对象 重写main方法，在里面实现想要执行的方法 在main方法中，创建自动释放池，因为如果是异步操作，无法访问主线程的自动释放池 经常通过cancelled属性检查方法是否取消，并且对取消的做出响应 响应取消事件 取消事件可以在任何时间发生 定期调用对象的isCancelled方法，如果返回“YES”，则立即返回，不再执行任务isCancelled方法本身非常轻量级，可以频繁调用，没有任何显着的性能损失 位置调用 在执行任何实际工作之前 在循环的每次迭代期间或者如果每次迭代相对较长，较频繁时至少调用一次 在代码中相对容易中止操作的任何点 并发 重写方法 必需重写四个方法：start、asynchronous、executing、finished start(必需)：所有并发操作必须重写此方法，并需要使用自定义的实现替换默认行为。任何时候都不能调用父类的start方法。 即不可使用super。重写的start方法负责以异步的方式启动一个操作，无论是开启一个线程还是调用异步函数，都可以在start方法中进行。注意在开始操作之前，应该在start中更新操作的执行状态，因为要给KVO的键路径发送当前操作的执行状态，方便查看操作状态。 main(可选)：在这个方法中，放置执行给定任务所需的代码。应该定义一个自定义初始化方法，以便更容易创建自定义类的实例。当如果定义了自定义的getter和setter方法，必须确保这些方法可以从多个线程安全地调用。虽然可以在start方法中执行任务，但使用此方法实现任务可以更清晰地分离设置和任务代码,即在start方法中调用mian方法。注意:要定义独立的自动释放池与别的线程区分开。 isFinished(必需)：表示是否已完成。需要实现KVO通知机制。 isAsynchronous(必需)：默认返回 NO ，表示非并发执行。并发执行需要自定义并且返回 YES。后面会根据这个返回值来决定是否并发。 isExecuting(必需)：表示是否执行中，需要实现KVO通知机制。 注意：自己创建自动释放池，异步操作无法访问主线程的自动释放池 使用实现例子如下：非并发的情况下需要重写main方法，并且最好添加一个init方法用于初始化数据。 123456789101112131415161718192021222324252627+ (instancetype)downloaderOperationWithURLPath:(NSString *)urlPath completeBlock:(CompleteBlock)completeBlock&#123; WNNoCurrentOPration *op = [[WNNoCurrentOPration alloc] init]; op.urlPath = urlPath; op.completeBlock = completeBlock; return op;&#125;// main一般只适合自定义非并发的,在里面实现想执行的任务- (void)main&#123; // 是异步的话 就会导致访问不到当前的释放池 @autoreleasepool &#123; NSLog(@&quot;%s&quot;,__func__); // 当处于取消操作，不执行任务功能 if (self.isCancelled) return; // 下载图片的耗时操作 NSURL *url = [NSURL URLWithString:self.urlPath]; NSData *data = [NSData dataWithContentsOfURL:url]; NSLog(@&quot;已下载 %@&quot;,[NSThread currentThread]); UIImage *image = [UIImage imageWithData:data]; // 主线程回调，完成操作后通知调用方完成回调 dispatch_async(dispatch_get_main_queue(), ^&#123; if (self.completeBlock != nil) &#123; self.completeBlock(image); &#125; &#125;); &#125;&#125; 六、GCD VS NSOperation GCD是苹果公司为多核的并行运算提出的解决方案，会自动利用更多的CPU内核(比如双核、四核)，而NSOperation是基于GCD的面向对象的封装，拥有GCD的特性。GCD是将任务(block)添加到队列(串行/并行/全局/主队列),并且以同步/异步的方式执行任务的函数，而NSOperation将操作(一般是异步的任务)添加到队列(一般是并发队列),就会执行指定操作的函数。 相对于NSThread或者是跨平台的pthread而言，GCD和NSOperation都是自动管理线程的生命周期，开发者只要专注于具体任务逻辑,不需要编写任何线程管理相关的代码。 GCD提供了一些NSOperation不具备的功能：延迟执行、一次性执行、调度组；NSOperation里提供了一些方便的操作：最大并发数、 队列的暂定/继续、取消所有的操作、指定操作之间的依赖关系(GCD可以用同步实现功能)； GCD是无法控制线程的最大并发数的，而NSOperation可以设置最大并发数，可以灵活的根据需要限制线程的个数。因为开辟线程需要消耗必要的资源。 何时使用GCD:调度队列(Dispatch queues)、分组(groups)、信号量(semaphores)、栅栏(barriers)组成了一组基本的并发原语。对于一次性执行，或者简单地加快现有方法的速度，使用轻量级的GCD分派(dispatch)比使用NSOperation更方便。 何时使用NSOperation:在特定队列优先级和服务质量(用于表示工作对系统的性质和重要性)下， 可以用一系列依赖来调度NSOperation对象 。与在GCD队列上调度的block不同，NSOperation可以被取消和查询其操作状态。通过子类化，NSOperation可以关联执行结果，以供之后参考。 注意：NSOperation和GCD不是互斥的。 七、队列VS线程VS任务从思维导图了解整个概况。 1. 队列(queue)队列是先进先出特征数据结构。并且队列只是负责任务的调度，而不负责任务的执行。。按照任务的调度方式可以分为串行队列和并发队列。特点总结如下： 串行队列 一个接一个的调度任务 无论队列中所指定的执行任务是同步还是异步，都会等待前一个任务执行完成后，再调度后面的任务。 并发队列 可以同时调度多个任务。 如果当前调度的任务是同步执行的，会等待任务执行完成后，再调度后续的任务。 如果当前调度的任务是异步执行的，同时底层线程池有可用的线程资源，会再新的线程调度后续任务的执行。 我们知道系统提供了2个队列：主队列和全局并发队列两种队列。我们还可以自己创建队列。 主队列 特点 添加到主队列中的任务，都会在主线程中执行。 专门用来在主线程上调度任务的队列。 在主线程空闲时才会调度队列中的任务在主线程执行。 不会开启线程。 串行。 获取 会随着程序启动一起创建。 主队列只需要获取不用创建。 主队列是负责在主线程调度任务的。 全局队列 本质是一个并发队列，由系统提供，方便编程，可以不用创建就直接使用。 全局队列是所有应用程序共享的 GCD的一种队列 全局队列没有名字，但是并发队列有名字。有名字可以便于查看系统日志 自定义队列 有2种方式：串行、并发。 添加到自定义队列中的任务，都会自动放在子线程中执行。 2. 线程(thread) 开辟线程具有一定的资源开销，iOS系统下主要成本包括：内核数据结构（大约1KB）、栈空间（子线程512KB、主线程1MB，也可以使用-setStackSize:设置，但必须是4K的倍数，而且最小是16K），创建线程大约需要90毫秒 对于单核CPU，同一时间CPU只能处理1条线程，即只有1条线程在执行，多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。 线程是CPU调度和分派且能独立运行基本单位。 线程执行任务，实际做事的功能单元。 异步：开辟新线程。 3. 任务(task)一定要分清队列、线程和任务这三者的关系：队列调度任务，将任务添加对应的线程上，然后任务是在线程中执行。 任务的执行分为同步和异步。 同步 当前任务未完成，不会执行下个任务 不具备开辟新线程能力 异步 当前任务未完成，同样可以执行下一个任务 具备开辟新线程能力，但是不一定会开辟线程。开辟线程需要CPU等资源，而系统资源有限。不可能开辟无限个线程。 推荐博客 NSOperation apple官方 NSHipster NSOperation]]></content>
      <categories>
        <category>iOS</category>
        <category>OC</category>
        <category>NSOperation</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>OC</tag>
        <tag>NSOperation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点：可变数组的属性使用copy修饰的后果]]></title>
    <url>%2F2018%2F11%2F16%2F%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8copy%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%90%8E%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[问题 视频What’s New in LLVM 中，从12:05的时间开始有个关于NSMutableArray可变数组属性的使用问题。 运行后报错图如下： 分析self.photos的实际类型是 __NSMutable0,也就NSArray类型。没有addObject的方法。 进一步探讨 OC是门动态型语言，在编译阶段不会做类型检测。OC的内存管理是引用计数，在ARC环境下，属性@property的内存管理语义关键字有copy,weak,strong,asssin。在编译阶段，默认情况下编译器会生成一个成员变量、一个setter方法、一个getter方法。而在setter方法中，会根据内存管理语义做相应的引用计数相关的操作。当使用copy修饰属性时，在setter中实际操作是拷贝了一份不可变的类型对象。这样的话，即使是其是可变类型，在被赋值后，我们得到的是却是不可变类型的对象。 OC具有多态性，父类可以指向子类。对象最终类型会在运行期根据实例化对象确认。在运行时阶段其isa指向的是[NSArray Class]。那么当向self.photos发送一个addObject消息时，self.photos对象是接收不到这个消息的。因为addObject是NSArray的子类NSMutbleArray的方法。 属性语义多种： 原子性（Atomicity）:原子性(atomic)、非原子性(nonatomic) Setter语义（Setter Semantics）:strong,weak,copy,asssin 读写属性(Writability): readwrite/readonly原子性是具有线程安全的，会在属性的setter方法内部加个一个自旋锁、而非原子性是不会在setter方法中加锁的，是非线程安全的。在小型设备的上，内存空间是有限的。给属性加自旋锁是非常消耗资源的。并且不一定说使用了原子性就能保证该属性线程安全。这个仅仅是在setter方法中是安全的，这也是atomic该做的事。如果绕开setter方法使用其他的方式给属性赋值，依然是不安全的，比如使用KVC。 ARC下，属性的默认语义是： 基本数据：atomic、assgin、readwrite 普通的OC对象：atomic、strong、readwrite 在此情况下，实际编译器添加setter方法如下：123456// ARC- (void)setPhotos:(NSMutableArray&lt;UIImage *&gt; *)photos&#123; // 1. 开始加锁，非自然语言，这里不写代码了 _photos = [photos copy]; // 2. 加锁结束&#125; 那么得到的是个self.photos实际是NSArray类。 从上就发现了2个问题：属性就是使用了关键字atomic、copy修饰。那么这里会加锁并且得到NSArray类的self.photos。 相关概念： 自旋锁：当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会一直等待（不会睡眠），当上一个线程的任务执行完毕，下一个线程会立即执行。 自旋锁应用场景：比较适合做一些不耗时的操作 解决1、修改copy语义在setter中默认内容： 方式一:手动重写setter方法，使用赋值前mutableCopy。如下，这样获取到的就是NSMutableArray类型的对象。123- (void)setPhotos:(NSMutableArray&lt;UIImage *&gt; *)photos&#123; _photos = [photos mutableCopy];&#125; 方式二:使用关键字strong修饰属性。我们得到的依然是可变类型。123- (void)setPhotos:(NSMutableArray&lt;UIImage *&gt; *)photos&#123; _photos = photos;&#125; 2、原子性修改：使用：nonatomic，减少小型设备中性能消耗。]]></content>
      <categories>
        <category>iOS</category>
        <category>OC</category>
        <category>NSMutableArray</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>OC</tag>
        <tag>NSMutableArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSThead的进阶使用和简单探讨]]></title>
    <url>%2F2018%2F11%2F15%2FNSThead%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E5%92%8C%E7%AE%80%E5%8D%95%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[概述NSThread类是一个继承于NSObjct类的轻量级类。一个NSThread对象就代表一个线程。它需要管理线程的生命周期、同步、加锁等问题，因此会产生一定的性能开销。使用NSThread类可以在特定的线程中被调用某个OC方法。当需要执行一个冗长的任务，并且不想让这个任务阻塞应用中的其他部分，尤其为了避免阻塞app的主线程(因为主线程用于处理用户界面展示交互和事件相关的操作),这个时候非常适合使用多线程。线程也可以将一个庞大的任务分为几个较小的任务，从而提高多核计算机的性能。 NSThread类在运行期监听一个线程的语义和NSOperation类是相似的。比如取消一个线程或者决定一个任务执行完后这个线程是否存在。 本文将会从这几个方面开始探讨NSThread 方法属性的介绍初始化(创建)一个NSThread对象123456789// 返回一个初始化的NSThread对象- (instancetype)init// 返回一个带有多个参数的初始化的NSThread对象// selector ：线程执行的方法,最多只能接收一个参数// target ：selector消息发送的对象// argument : 传给selector的唯一参数，也可以是nil- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument );// iOS 10- (instancetype)initWithBlock:(void (^)(void))block; 启动一个线程。 12345678910// 开辟一个新的线程，并且使用特殊的选择器Selector作为线程入口,调用完毕后，会马上创建并开启新线程+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument; // iOS 10+ (void)detachNewThreadWithBlock:(void (^)(void))block;// 启动接受者- (void)start;// 线程体方法，线程主要入口，start 后执行// 该方法默认实现了目标(target)和选择器(selector)，用于初始化接受者和调用指定目标(target)的方法。如果子类化NSThread，需要重写这个方法并且用它来实现这个线程主体。在这种情况下，是不需要调用super方法的。// 不应该直接调用这个方法。你应该通过调用启动方法开启一个线程。- (void)main; 使用initWithTarget:selector:、initWithBlock:、detachNewThreadSelector:，detachNewThreadWithBlock:创建线程都是异步线程。 停止一个线程12345678// 阻塞当前线程，直到特定的时间。+ (void)sleepUntilDate:(NSDate *)date;// 让线程处于休眠状态，直到经过给定的时间间隔+ (void)sleepForTimeInterval:(NSTimeInterval)ti;// 终止当前线程+ (void)exit;// 改变接收者的取消状态，来表示它应该终止- (void)cancel; 决定线程状态123456// 接收者是否存在@property (readonly, getter=isExecuting) BOOL executing;// 接收者是否结束执行@property (readonly, getter=isFinished) BOOL finished;// 接收者是否取消@property (readonly, getter=isCancelled) BOOL cancelled; 主线程相关123456// 当前线程是否是主线程@property (class, readonly) BOOL isMainThread;// 接受者是否是主线程@property (readonly) BOOL isMainThread;// 获取主线程的对象@property (class, readonly, strong) NSThread *mainThread; 执行环境12345678// 这个app是否是多线程+ (BOOL)isMultiThreaded;// 返回当前执行线程的线程对象。@property (class, readonly, strong) NSThread *currentThread;// 返回一个数组，包括回调堆栈返回的地址@property (class, readonly, copy) NSArray&lt;NSNumber *&gt; *callStackReturnAddresses ;// 返回一个数组，包括回调堆栈信号@property (class, readonly, copy) NSArray&lt;NSString *&gt; *callStackSymbols; 线程属性相关12345678// 线程对象的字典@property (readonly, retain) NSMutableDictionary *threadDictionary;NSAssertionHandlerKey// 接收者的名字@property (nullable, copy) NSString *name;// 接收者的对象大小，以byte为单位@property NSUInteger stackSize; 线程优先级12345678// 线程开启后是个只读属性@property NSQualityOfService qualityOfService;// 返回当前线程的优先级+ (double)threadPriority;// 接受者的优先级，已经废弃，使用qualityOfService代替@property double threadPriority;// 设置当前线程的优先级。设置线程的优先级(0.0 - 1.0，1.0最高级)+ (BOOL)setThreadPriority:(double)p; 通知123456// 未被实现，没有实际意义，保留项NSDidBecomeSingleThreadedNotification// 在线程退出前，一个NSThread对象收到到退出消息时会发送这个通知。NSThreadWillExitNotification// 当第一个线程启动时会发送这个通知。这个通知最多发送一次。当NSThread第一次发送用`detachNewThreadSelector:toTarget:withObject:`,`detachNewThreadWithBlock:`,`start`消息时，发送通知。后续调用这些方法是不会发送通知。NSWillBecomeMultiThreadedNotification 线程间通信，在NSObject的分类NSThreadPerformAdditions中的方法(NSThread.h文件中)具有这些特性： 无论是在主线程还是在子线程中都可执行，并且均会调用主线程的aSelector方法； 方法是异步的1234567891011121314151617@interface NSObject (NSThreadPerformAdditions)// 如果设置wait为YES: 等待当前线程执行完以后，主线程才会执行aSelector方法；// 如果设置wait为NO：不等待当前线程执行完，就在主线程上执行aSelector方法。// 如果，当前线程就是主线程，那么aSelector方法会马上执行，wait是YES参数无效。- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;// 等于第一个方法中modes是kCFRunLoopCommonModes的情况。指定了线程中 Runloop 的 Modes = kCFRunLoopCommonModes。- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;// 在指定线程上操作，因为子线程默认未添加NSRunloop，在线程未添加runloop时，是不会调用选择器中的方法的。- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait modes:( NSArray&lt;NSString *&gt; *)array ;// 等于第一个方法中modes是kCFRunLoopCommonModes的情况。- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait ;// 隐式创建子线程,在后台创建。并且是个同步线程。- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg ;@end 直接给接受者发消息的其他方法。 协议NSObject中的方法，可在主线程或者子线程执行。因为是在当前线程执行的同步任务，因此会阻塞当前线程。这几个方法等同于直接调用方法。 1234// 当前线程操作。- (id)performSelector:(SEL)aSelector;- (id)performSelector:(SEL)aSelector withObject:(id)object;- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2; 延迟操作&amp;按照顺序操作 NSRunLoop.h文件中1234567891011121314151617181920212223242526// 延迟操作/**************** Delayed perform ******************/@interface NSObject (NSDelayedPerforming)// 异步方法，不会阻塞当前线程，只能在主线程中执行。是把`Selector`加到主队列里，当 `delay`之后执行`Selector`。如果主线程在执行业务，那只能等到执行完所有业务之后才会去执行`Selector`，就算`delay`等于 0。// 那`delay `从什么时候开始计算呢？从发送`performSelector`消息的时候。就算这时主线程在阻塞也会计算时间，当阻塞结束之后，如果到了`delay`那就执行`Selector`，如果没到就继续 `delay`。// 只能在主线程中执行，在子线程中不会调到aSelector方法- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;// 等于第一个方法中modes是kCFRunLoopCommonModes的情况。指定了线程中 Runloop 的 Modes = kCFRunLoopCommonModes。- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;// 在方法未到执行时间之前，取消方法。调用这2个方法当前target执行dealloc之前，以确保不会Crash。+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget;@end// 按照排序顺序执行@interface NSRunLoop (NSOrderedPerform)// 按某种顺序order执行方法。参数order越小，优先级越高，执行越早// selector都是target的方法，argument都是target的参数// 这2个方法会设置一个定时器去在下个runloop循环的开始时让target执行aSelector消息。 定时器根据modes确认模式。当定时器触发，定时器尝试队列从runloop中拿出消息并执行。如果run loop 正在运行，并且是指定modes的一种，则是成功的，否则定时器一直等待直到runloop是modes 中的一种。- (void)performSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg order:(NSUInteger)order modes:(NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)cancelPerformSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg;- (void)cancelPerformSelectorsWithTarget:(id)target;@end 本文介绍大部分的知识点如思维导图： 使用 创建线程用initXXX初始化的需要调用start方法来启动线程。而detachXXX初始化方法，直接启动线程。这个2中方式创建的线程都是显式创建线程。 1234567891011121314//1. 手动开启，action-target 方式NSThread * actionTargetThread = [[NSThread alloc] initWithTarget:self selector:@selector(add:) object:nil];[actionTargetThread start];//2. 手动开启， block 方式NSThread *blockThread = [[NSThread alloc] initWithBlock:^&#123; NSLog(@&quot;%s&quot;,__func__);&#125;];[blockThread start];//3. 创建就启动， action-target 方式[NSThread detachNewThreadSelector:@selector(add2:) toTarget:self withObject:@&quot;detachNewThreadSelector&quot;];//4. 创建就启动， block 方式[NSThread detachNewThreadWithBlock:^&#123; NSLog(@&quot;%s&quot;,__func__);&#125;]; 线程中通信 2.1 NSThreadPerformAdditions分类方法，异步调用方法// 无论在子线程还是主线程，都会调用主线程方法。 a. 主线程 12[self performSelectorOnMainThread:@selector(add:) withObject:nil waitUntilDone:YES];//[self performSelectorOnMainThread:@selector(add:) withObject:@&quot;arg&quot; waitUntilDone:YES modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]]; 子线程默认没有开启runloop。需要手动添加，不然选择器方法无法调用。 b. 子线程 使用initWithBlock:方式创建。1234567891011//1. 开辟一个子线程NSThread *subThread1 = [[NSThread alloc] initWithBlock:^&#123; // 2.子线程方法中添加runloop // 3.实现线程方法 [[NSRunLoop currentRunLoop] run];&#125;];//1.2. 启动一个子线程[subThread1 start];// 2. 在子线程中调用方法// [self performSelector:@selector(add:) onThread:subThread1 withObject:@&quot;22&quot; waitUntilDone:YES];[self performSelector:@selector(add:) onThread:subThread1 withObject:@&quot;arg&quot; waitUntilDone:YES modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]]; 使用initWithTarget:selector:object:创建。1234567891011// 1. 开辟一个子线程NSThread *subThread2 = [[NSThread alloc] initWithTarget:self selector:@selector(startThread) object:nil];// 1.2 启动一个子线程[subThread2 start];// 3. 在子线程中调用方法// [self performSelector:@selector(add:) onThread:subThread2 withObject:@&quot;22&quot; waitUntilDone:YES];[self performSelector:@selector(add:) onThread:subThread1 withObject:@&quot;arg&quot; waitUntilDone:YES modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]];// 2.子线程方法中添加runloop- (void)startThread&#123; [[NSRunLoop currentRunLoop] run];&#125; c. 后台线程(隐式创建一个线程) 1[self performSelectorInBackground:@selector(add:) withObject:@&quot;arg&quot;]; 2.2 协议NSObject方法创建是的同步任务。1234[NSThread detachNewThreadWithBlock:^&#123; // 直接调用 [self performSelector:@selector(add:) withObject:@&quot;xxx&quot;];&#125;]; 2.3 延迟NSObject分类NSDelayedPerforming方法，添加异步任务，并且是在主线程上执行。1[self performSelector:@selector(add:) withObject:self afterDelay:2]; 2.4 按照顺序操作NSRunLoop分类NSOrderedPerform中的方法12345678[NSThread detachNewThreadWithBlock:^&#123; NSRunLoop *currentRunloop = [NSRunLoop currentRunLoop]; // 记得添加端口。不然无法调用selector方法 [currentRunloop addPort:[NSPort port] forMode:(NSRunLoopMode)kCFRunLoopCommonModes]; [currentRunloop performSelector:@selector(add:) target:self argument:@&quot;arg1&quot; order:1 modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]]; [currentRunloop performSelector:@selector(add:) target:self argument:@&quot;arg3&quot; order:3 modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]]; [currentRunloop run];&#125;]; 线程安全问题： 多个线程可能会同时访问同一块资源。比如多个线程同时访问同一个对象、同一个变量、同一个文件等。当多个线程同时抢夺同一个资源，会引起线程不安全性，可能会造成数据错乱和数据安全问题。 解决： 使用线程同步技术: 可以对可能会被抢夺的资源，在被被竞争的时候加锁。让其保证线程同步状态。而锁具有多种类型：比如读写锁、自旋锁、互斥锁、信号量、条件锁等。在NSThread可能造成资源抢夺情况下，可以使用互斥锁。互斥锁就是多个线程任务按顺序的执行。如下就使用的情况之一：对需要读写操作的资源，进行加锁操作。123456for (NSInteger index = 0 ; index &lt; 100; index ++) &#123; @synchronized (self) &#123; self.allCount -= 5; NSLog(@&quot;%@卖出了车票，还剩%ld&quot;,[NSThread currentThread].name,self.allCount); &#125;&#125; 线程生命周期。线程的生命周期是：新建 - 就绪 - 运行 - 阻塞 - 死亡。当线程启动后，它不能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也就会随之改变。 新建和就绪状态显式创建，使用initWithTarget:selector:和initWithBlock:创建一个线程，未启动，只有发送start消息才会启动，然后处于就行状态。使用detachNewThreadWithBlock:和detachNewThreadSelector:toTarget:显示创建并立即启动。 还有种创建方式，隐式创建并立即启动:performSelectorInBackground:withObject:。 运行和阻塞状态如果处于就绪状态的线程获得了CPU资源，开始执行可执行方法的线程执行体(block或者@Selector)，则该线程处于运行状态。 当发生如下情况下，线程将会进入阻塞状态： 线程调用sleep方法:sleepUntilDate: sleepForTimeInterval:主动放弃所占用的处理器资源。 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。线程试图获得一个同步监视器，但该同步监视器正被其他线程锁持有。 线程在等待某个通知(notify)。 程序调用了线程的suspend方法将该线程挂起。不过这个方法容易导致死锁，所以程序应该尽量避免使用该方法。 当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会了。被阻塞的线程会在合适时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。针对上面的几种情况，当发生如下特定的情况将可以解除上面的阻塞，让该线程重新进入就绪状态： 调用sleep方法的线程经过了指定时间。 线程调用的阻塞式IO方法已经返回。 线程成功地获得了试图取得同步监视器。 线程正在等待某个通知时，其他线程发出了一个通知。 处于挂起状态的线程被调用了resume恢复方法。 线程死亡 可执行方法执行完成，线程正常结束。 程序的意外奔溃。 该线程的发送exit消息来结束该线程。 1234567891011121314151617// 1. 创建：New状态NSThread * actionTargetThread = [[NSThread alloc] initWithTarget:self selector:@selector(add:) object:nil];// 2. 启动：就绪状态[actionTargetThread start];// 可执行方法- (void)add:(id)info&#123; // 3. 执行状态 NSLog(@&quot;%s,info %@&quot;,__func__,info); // 5. 当前线程休眠 [NSThread sleepForTimeInterval:1.0]; NSLog(@&quot;after&quot;); // 4. 程序正常退出&#125;// 6. 打取消标签[actionTargetThread cancel];// 7. 主动退出[NSThread exit]; 注意： NSThread 管理多个线程比较困难,所以不太推荐在多线程任务多的情况下使用。 苹果官方推荐使用GCD和NSOperation。 [NSTread currentThread] 跟踪任务所在线程,适用于NSTread,NSOperation,和GCD 用NSThread创建的线程,不会自动添加autoreleasepool 参考 nsthread apple 文档 线程的生命周期 线程的生命周期及五种基本状态]]></content>
      <categories>
        <category>iOS</category>
        <category>OC</category>
        <category>NSThread</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>OC</tag>
        <tag>NSThread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS缓存策略之NSCache的简单使用]]></title>
    <url>%2F2018%2F11%2F15%2FiOS%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E4%B9%8BNSCache%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[NSCache是一个继承NSObjec的可变集合，是苹果提供的一套缓存机制，用键值(key-value)对来临时存储只需要短暂存储在内存中的数据，并且当内存空间很少的时候会可以自动释放一些资源。 概观缓存(cache)对象和其他可变集合不同的几个方面。 NSCache类包含了各种自动销毁策略，来保证缓存内容没有占用过多的系统内存。如果其他应用需要内存，这些策略会从系统中移除一些选项内容，来减少当前app占用的内存空间。 可以在不同的线程中对内存中的缓存执行添加、移除和查询操作，而不必自己锁住缓存,因为是线程安全的。 不同于NSMutableDictionary对象，缓存使用的key是不需要是实现NSCopying协议的，NSMutableDictionary是非线程安全的，在OC中可变类型一般都是非线程安全的。 NSCache可以指定缓存数量(限额)和一共可用的空间容量，当缓存超出限额或者可用内存容量会自动释放相应内存。 通常使用NSCache对象去临时存储那些创建很昂贵的过渡数据。重用这些数据可以提供性能优势，因为这些值没必要被重新计算。有些数据并非是关键数据，在内存紧张的时候，可以被丢弃。如果丢弃，这些值将会被重新计算。 具有子组件的对象在没有被使用时可以被丢弃，该对象可以采用NSDiscardableContent协议，去提高缓存回收行为。默认情况下。在缓存中的NSDiscardableContent对象丢弃的内容会被自动移出缓存，即使这个自动移除政策是可以修改的。如果一个NSDiscardableContent对象被放进缓存中，那么当该对象被移出时会调用discardContentIfPossible。 使用以下可以使用，从多个方法介绍NSCache。 12// 缓存的名称@property (copy) NSString *name; 设置缓存空间1234// 对象缓存可持有最大的数量 ，默认是0 没有限制），一旦超出限额，会自动删除之前添加的缓存数据@property NSUInteger countLimit;// 缓存中可持有的最大空间 默认是0（没有限制）@property NSUInteger totalCostLimit; 管理丢弃内容1234// 是否可以自动缓存清除可丢弃的内容，默认是YES@property BOOL evictsObjectsWithDiscardedContent;// 可以实现这个协议，当类的对象有可以被销毁不再使用的子组件。这样使用app占用更少的内存空间。NSDiscardableContent 设置代理1234// cache的代理@property (nullable, assign) id&lt;NSCacheDelegate&gt; delegate;// 一个NSCache对象的代理，实现这些协议代理，去将对象从缓存中移除NSCacheDelegate 获取一个缓存值 12// 返回给定key关联的value值- (nullable ObjectType)objectForKey:(KeyType)key; 添加和移除缓存值 12345678// 根据key值设置在缓存中的value值- (void)setObject:(ObjectType)obj forKey:(KeyType)key; // 0 cost// 根据key值设置在缓存中的value值，并且指定关联key-value对的成本- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;// 根据key值移除在缓存的value值- (void)removeObjectForKey:(KeyType)key;// 清空全部缓存，调用次方法依然可以添加新值，网上很多复制粘贴的博客，都说调用次方法后不能添加，亲测是可以的。- (void)removeAllObjects; NSCacheDelegate 方法1234567@protocol NSCacheDelegate &lt;NSObject&gt;@optional// 回收内存空间使用。// cache 缓存对象。// obj 被回收的对象。- (void)cache:(NSCache *)cache willEvictObject:(id)obj;@end 在NSObject.h中的可以废弃内容。12345678910111213/*********** Discardable Content ***********/@protocol NSDiscardableContent@required- (BOOL)beginContentAccess;- (void)endContentAccess;- (void)discardContentIfPossible;- (BOOL)isContentDiscarded;@end@interface NSObject (NSDiscardableContentProxy)@property (readonly, retain) id autoContentAccessingProxy;@end 使用 初始化对象 1234567891011// 1. 初始化数据- (NSCache *)mainCache&#123; if (!_mainCache) &#123; _mainCache = [[NSCache alloc] init]; _mainCache.countLimit = 300; // 限制个数，默认是0，无限空间 _mainCache.totalCostLimit = 5*1024*1024; // 设置大小设置，默认是0，无限空间 _mainCache.name = @&quot;cache1&quot;; _mainCache.delegate = self; &#125; return _mainCache;&#125; 添加缓存 12// 添加缓存 [self.mainCache setObject:data forKey:str]; 移除。在内存警告的时候（didReceiveMemoryWarning）移除缓存。给对象发送removeAllObjects，后添加缓存setObject:forKey:是可以的，可以再添加进去的。还有一个根据key移除对应的值。 12[self.mainCache removeAllObjects];//[self.mainCache removeObjectForKey:@&quot;XXX&quot;]; 代理在当前对象遵守NSCacheDelegate协议。并且实现协议。并且让当前对象成为代理_mainCache.delegate = self; 123- (void)cache:(NSCache *)cache willEvictObject:(id)obj&#123; NSLog(@&quot;%s&quot;,__func__);&#125; 推荐 Apple NSCache 文档]]></content>
      <categories>
        <category>iOS</category>
        <category>OC</category>
        <category>NSCache</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>OC</tag>
        <tag>NSCache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点：id和NSObject *对比，以及id 介绍]]></title>
    <url>%2F2018%2F11%2F06%2Fid-NSObject%2F</url>
    <content type="text"><![CDATA[在obj.h的类文件中，可以看出id类型和NSObject类型的信息。如下： 类 id12345678/// An opaque type(隐含类型) that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa ;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 类 NSObject123@interface NSObject &lt;NSObject&gt; &#123; Class isa ;&#125; 协议 NSObject12@protocol NSObject@end 类 NSProxy123@interface NSProxy &lt;NSObject&gt; &#123; Class isa;&#125; id和NSObject对比 从上面的源码可以看出，id是struct objc_object结构体指针,可以指向任何OC对象，当然不包括NSInteger等，因为这些数据类型不是OC对象。另外OC的基类，其实不仅仅就NSObject一个，虽然NSObject是绝大数OC对象的基类，但是还有个NSProxy虚类。所以不能说id类型和NSObject *是等价的。 id类型的实例在编译阶段不会做类型检测，会在运行时确定，所以id类型是运行时的动态类型。类NSObject的实例会编译期要做编译检查，保证指针指向是其NSObject类或其子类，当然实例的具体类型要在运行期确定，这也是iOS的多态的体现。 id指针的会有局限性：调用方法,只能使用中括弧，不能使用点语法。 id \ 是什么呢？这里的NSObject是协议NSObject(protocol)而非类NSObject。所以这里表示是遵守协议NSObject的所以类。另外NSObject类和NSProxy类都是实现了协议NSObject。 不错的推荐： oc runtime源码 版本 objc4-723]]></content>
      <categories>
        <category>iOS</category>
        <category>OC</category>
        <category>id</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>OC</tag>
        <tag>id</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOSBug:The operation couldn’t be completed. (DVTCoreSimulatorAdditionsErrorDomain error 0.)]]></title>
    <url>%2F2018%2F10%2F29%2FiOS%E6%A8%A1%E6%8B%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言查看磁盘空间的时候，发现系统磁盘消耗太多空间。而且显示是系统消耗的。然后就大举的删除了很多关了XCode和模拟器本地资源。然后运行XCode。发现模拟器一直调不出来，并且XCode提示这个错误，如下 The operation couldn’t be completed. (DVTCoreSimulatorAdditionsErrorDomain error 0.) 解决方案：重新启动mac]]></content>
      <categories>
        <category>iOS</category>
        <category>bug</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4异常处理Try_Catch的使用之初见]]></title>
    <url>%2F2018%2F10%2F26%2FSwift4%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86Try-Catch%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%88%9D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[前言从OC转Swift了。虽然Swift的官方语法的资料看了2遍了。还是在使用的时候遇到点问题。好记性，不如烂笔头。本篇不是高深的内容。只是作为初使用的记录。 当想给一个函数使用try-catch。需要在函数后加个throws。具体使用，如下先有个错误的枚举1234enum ErrorType:Error&#123; case ErrorTypeNil case ErrorType1&#125; 这里需要函数出错会抛出错误的情况，记住后面要加throws。 123456789func largerThanEighteenthFunc(a:Int16?) throws &#123; if let need = a ,need &gt;= 18&#123; print("need &gt;&gt;&gt;&gt; \(need)") throw ErrorType.ErrorTypeNil &#125;else&#123; print("need &lt;=18") throw ErrorType.ErrorType1 &#125;&#125; 不需要捕抓错误，可以使用try!或try?。但是不建议不建议使用try!，使用try?会更加安全。因为如果当有错误捕抓到时，程序会直接崩溃123func notPrintError() &#123; try? largerThanEighteenthFunc(a: nil) &#125; 如果只包含一个catch语句，那么所有的错误都会在这个catch中执行，能够捕抓其错误信息 1234567func oneCondition() &#123; do &#123; try largerThanEighteenthFunc(a: 9) &#125; catch let error &#123; print("error &gt;&gt;&gt; \(error)") &#125; &#125; 在使用catch时，我们想它是能够进行模式匹配的、能够进行更精准的错误匹配处理。可以穷举多种情况。12345678910func twoCondition() &#123; do &#123; try largerThanEighteenthFunc(a: 20) &#125; catch ErrorType.ErrorTypeNil &#123; print(ErrorType.ErrorTypeNil) &#125; catch ErrorType.ErrorType1 &#123; print(ErrorType.ErrorType1) &#125; catch &#123; // 加入一个空的catch，用于关闭catch。否则会报错：Errors thrown from here are not handled because the enclosing catch is not exhaustive &#125;&#125; 注意：在使用do-catch的时候。无论是不是把错误都穷举完，一定要写个空catch，不然会报错。这个错误就是 Errors thrown from here are not handled because the enclosing catch is not exhaustive 友情连接： 本文代码的github地址]]></content>
      <categories>
        <category>Swift</category>
        <category>try_catch</category>
      </categories>
      <tags>
        <tag>Swift - try_catch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift代理协议的安全使用]]></title>
    <url>%2F2018%2F10%2F25%2FSwift%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[文章Swift代理协议的安全使用 概述在Swift下，使用代理协议，并且检验代理对象的存在和协议函数是否被实现。 前言可空链式调用（Optional Chaining）是一种可以请求和调用属性、方法及下标的过程，它的可空性体现于请求或调用的目标当前可能为空（nil）。如果可空的目标有值，那么调用就会成功；如果选择的目标为空（nil），那么这种调用将返回空（nil）。多个连续的调用可以被链接在一起形成一个调用链，如果其中任何一个节点为空（nil）将导致整个链调用失败。 注意： Swift 的可空链式调用和 Objective-C 中的消息为空有些相像，但是 Swift 可以使用在任意类型中，并且能够检查调用是否成功。 空链式（Optional Chaining）的使用之一在Swift中空链式的有个实用例子，就是编写代理的时候。当触发协议方法的时候，因为OC是消息型语言，所以必须要判断这个实例是否存在并且要判断当前方法是否被实现，不然没有实现的话，Runtime期间，就可能会报错。又因为OC几乎所以的类都是继承基类NSObject，而根类NSObject实现了其协议NSObject的协议方法respondsToSelector:,该方法可以判断某个方法实现的。如下 1234// 判断添加了代理对象，并且该对象实现了某个协议方法if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(protocalMethod)]) &#123; [self.delegate protocalMethod];&#125; 而在Swift语言中，并未要求继承某个根类。并且也未提供某个方法去不判断某个方法是否被实现。其实因为Swift的语言一个特性–可选性，就很好解决这些问题了。正如上方的描述，如果其中任何一个节点为空（nil）将导致整个链调用失败。如下1self.delegate?.SwiftProtocolTest?() 当判读使用有代理对象的时候，只需在属性delegate添加”?”就行，而需要判断某个函数是否实现只需在函数名和()之间添加”?”就行。 提示：本文delegate在Swift和OC的对比可以查看 github 代码 友情提示： Apple-optional文档 using_delegates_to_customize_object_behavior]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
        <category>delegate</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>delegate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发环境下PP文件的创建]]></title>
    <url>%2F2018%2F10%2F23%2F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8BPP%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[开发环境下Provisioning Profile文件的创建。当我们在做iOS开发的时候,总是添加很多证书，来保证安全性。Provisioning Profile我们又称PP文件。这个文件将证书、App Id和设备相关联。本章节就是教大家如何创建开发环境下的PP文件。 通过该Certificates,Identifiers&amp;Profiles–&gt; Provisioning Profiles–&gt; Development路径，找到Profile文件的列表页面。添加+准备添加新的PP文件。 2.选择证书的类型，这里选择开发证书。 3.选择APPID&amp;证书&amp;设备。 3.1 选择对应的 APP ID 3.2 选择对应的证书 3.3 选择可以安装软件的设备号，设备号也就是每个硬件设备的序列号。 填写这个PP文件的名称。 走到这步，说明已经安装成功。点击按钮Download就可以下载了。 over，是不是很简单。正式环境的PP文件，也是大同小异。有时间也出篇教程。]]></content>
      <categories>
        <category>iOS</category>
        <category>PP文件</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>PP文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发实用软件之NWPusher]]></title>
    <url>%2F2018%2F10%2F23%2FiOS%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%B9%8BNWPusher%2F</url>
    <content type="text"><![CDATA[一个App获取到一个Push内容。必须是服务器拿着对应token和需要的消息内容发给苹果服务器，然后由苹果服务器推送给用户。作为前端开发人员，为了学习Push，去搭建一个服务器，还是很耗时的。想了解iOS推送系列之Push的工作原理，可以查看这篇博客。 现在有个软件NWPusher可以模拟服务器发送Push。为我们研究Push提供了便利，我们一起来了解下。 一、软件的安装多种方式： 使用Homebrew cask 1brew cask install pusher 直接安装Pusher.app 可以下载软件：最新的下载地址 NWPusher可以可以当做framework使用。这个也有2种方式。 3.1 使用CocoaPods 1pod &apos;NWPusher&apos;, &apos;~&gt; 0.7.0&apos; 3.2 使用Carthage 1github &quot;noodlewerk/NWPusher&quot; 二、软件的介绍软件界面如图：如图所示： 我们需要选择相应的Push开发测试证书，如果创建证书，可以查看开发环境Push证书的创建图文流程这篇博客了解相应的知识。 添加相应的deviceToken 选择过期时间:有8种选择。 Expiry:None : 不会过期 immediate(0) :立即 1 minute :1分钟时 5 minutes :5分钟时 1 hour :1小时时 1 day :1天时 Far past(1) :遥远的过去 Far future: :永远 选择优先级：3个 Pirority:None :没有优先级 Conserve power(5) : 电量优先 immediately(10) : 立刻，其优先级最高 Payload输入内容就是我们需要传送的数据了：这个数据传输以JSON的格式存储。是必要按照APNs发送的Push格式的。Push消息常用的key如下： aps,是其value是我们需要传送的内容。 alert,是其value就是弹出框需要展示的内容。 badge,是其value就是APP icon，展示的信息个数。 sound,是其value就是表示当有Push消息的时候，是否需要声音提示。 另外，alert中value值，可以是字符串，可以是字典。这个字典可以使用多对值，比如其key是title,subtitle,body等。其格式如下1234567891011&#123; "aps": &#123; "alert": &#123; "title": "title", "subtitle": "subTitle", "body": "body" &#125;, "badge": 1, "sound": "default" &#125;&#125; 更多关于aps,alert,sound等可以查看官网：Generating a Remote Notification 所以都填选好，点击按钮 Push。就可以发送了。其发送状态，边上都有发布状态的提示信息。 友情链接： Generating a Remote Notification NWPusher github地址 搭建Push环境]]></content>
      <categories>
        <category>iOS</category>
        <category>push</category>
      </categories>
      <tags>
        <tag>push</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发环境Push证书的创建图文流程]]></title>
    <url>%2F2018%2F10%2F22%2F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83Push%E8%AF%81%E4%B9%A6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%9B%BE%E6%96%87%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[当写Push的时候，必须有相应的证书。而证书的创建也是个知识点。今天以图文的形式写个相关的证书创建的流程。生成对应的APP ID 和证书 一.添加App ID1.进入苹果开发中心的App Id 选择 Cerfificates,Identifiers&amp;Profiles –&gt; Identifiers –&gt; App IDs 点击右上角的+来添加证书。 2.注册一个App ID 在这个页面填写和选择相应的 在App ID Description –&gt; name 输入相应的App Name 在App ID Suffix –&gt; Explicit App ID –&gt; Bundle ID 输入相应的bundle id 在 App Services –&gt; Enable Services 选择相应的服务。这里选项 Push Notifications。点击continue生成对应的app id 3. 确认App Id，这个页面不需要填选任何内容。检查下即将创建的App ID的内容，是否正确。 点击Rigister注册。 4. 完成操作点击Done完成操作。这个时候App ID就创建成功了。 生成APP ID 之后，再生成对应的证书，用于身份认证。 二. 进入苹果开发中心的证书1. 进入开发环境证书列表页 选择 Cerfificates,Identifiers&amp;Profiles –&gt; Cerfificates –&gt; Development 点击右上角的+来添加证书。 2. 选择证书类型2.1. 因为是需要添加推送证书，选择的证书了类型Apple Push Notification server SSL(SandBox)。然后下一步 2.2. 选择添加App Id 3. 提交点子信息证书的请求相应证书创建电子信息证书步骤是提示,点击continue. 4. 生成选择添加本地请求文件。如何创建请求文件，从下面的第三部分：创建电子信息证书的步骤获取。 5. 下载证书已经生成成功，下载到本地。 6. 添加到钥匙串下载的文件aps_development.cer,双击这个文件来安装。安装成功就会跳转到钥匙串的证书部分，表示安装成功。 三. 电子证书请求文件的创建。 在进入钥匙串中 创建电子签名请求 a. 钥匙串访问 –&gt; 证书助理 –&gt; 从证书颁发机构请求... b. 填写添加邮件,选择存储到磁盘。点击继续,选择保存到本地的位置，保存到本地。c.本地的电子签名请求 以上就是整个开发环境Push证书的创建过程。 参考: 搭建Push环境上]]></content>
      <categories>
        <category>iOS</category>
        <category>push</category>
        <category>证书</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>push</tag>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中Class和Struct异同]]></title>
    <url>%2F2018%2F10%2F17%2FSwift%E4%B8%ADClass%E5%92%8CStruct%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[Swift 中类和结构体有很多共同点。共同处在于： 定义属性用于存储值 定义方法用于提供功能 定义下标操作使得可以通过下标语法来访问实例所包含的值 定义构造器用于生成初始化值 通过扩展以增加默认实现的功能 实现协议以提供某种标准功能 与结构体相比，类还有如下的附加功能： 继承允许一个类继承另一个类的特征 类型转换允许在运行时检查和解释一个类实例的类型 析构器允许一个类实例释放任何其所被分配的资源 引用计数允许对一个类的多次引用 Tip: 类的对象是引用类型，而结构体是值类型。所以类的赋值是传递引用，结构体则是Copy传值,不是使用引用计数。 类为支持的额外功能会增加其复杂性。一般,更倾向使用选择结构和枚举,因为他们更容易理解,而类，则当再在合适和必要的时候使用。实际上,这意味着大多数的自定义数据类型定义为结构和枚举就可以了。更详细的比较,请参阅结构和类之间的选择。 定义语法类和结构体有着类似的定义方式。我们通过关键字class和struct来分别表示类和结构体，并在一对大括号中定义它们的具体内容： 123456class SomeClass &#123; // 在这里定义类&#125;struct SomeStructure &#123; // 在这里定义结构体&#125; 注意 在定义一个新类或者结构体的时候，实际上是定义了一个新的 Swift 类型。因此请使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），以便符合标准 Swift 类型的大写命名风格（如String，Int和Bool）。相反的，请使用lowerCamelCase这种方式为属性和方法命名（如framerate和incrementCount），以便和类型名区分。 以下是定义结构体和定义类的示例：1234567891011struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?&#125; 类和结构体实例生成结构体和类实例的语法非常相似：12let someResolution = Resolution()let someVideoMode = VideoMode() 结构体和类都使用构造器语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如Resolution()或VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。 属性访问通过使用点语法,访问实例的属性.12print("The width of someResolution is \(someResolution.width)")// 打印 "The width of someResolution is 0" 可以访问子属性12print("The width of someVideoMode is \(someVideoMode.resolution.width)")// 打印 "The width of someVideoMode is 0" 可以使用点语法为变量属性赋值123someVideoMode.resolution.width = 1280print("The width of someVideoMode is now \(someVideoMode.resolution.width)")// 打印 "The width of someVideoMode is now 1280" 结构体类型的成员逐一构造器所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：1let vga = Resolution(width:640, height: 480) 与结构体不同，类实例没有默认的成员逐一构造器。 结构体和枚举是值类型值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。 实际上，在Swift中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。 在Swift中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。 类是引用类型与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。 恒等运算符因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符： 等价于（===） 不等价于（!==） 运用这两个运算符检测两个常量或者变量是否引用同一个实例： 1234if tenEighty === alsoTenEighty &#123; print("tenEighty and alsoTenEighty refer to the same Resolution instance.")&#125;//打印 "tenEighty and alsoTenEighty refer to the same Resolution instance." 请注意，“等价于”（用三个等号表示，===）与“等于”（用两个等号表示，==）的不同： “等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。 “等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法。 指针C，C++ 或者Objective-C语言使用指针来引用内存中的地址。一个引用某个引用类型实例的 Swift 常量或者变量，与C语言中的指针类似，但是并不直接指向某个内存地址，也不要求你使用星号（*）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。 类和结构体的选择结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。 按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体： 该数据结构的主要目的是用来封装少量相关简单数据值。 有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。 该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。 该数据结构不需要去继承另一个既有类型的属性或者行为。 举例来说，以下情境中适合使用结构体： 几何形状的大小，封装一个width属性和height属性，两者均为Double类型。 一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。 三维坐标系内一点，封装x，y和z属性，三者均为Double类型。 在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。 字符串、数组、和字典类型的赋值与复制行为Swift中，所以基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。 Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。 注意以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。 参考： 苹果 swift - Structures and Classes 中文翻译类与结构体]]></content>
      <categories>
        <category>Swift</category>
        <category>Class</category>
        <category>Struct</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS推送系列之Push的工作原理]]></title>
    <url>%2F2018%2F10%2F17%2FPrincipleOfPush%2F</url>
    <content type="text"><![CDATA[Push的工作原理 要理解Push的工作原理，我们必须要知道几个知识点。 设备是如何和APNs保持连接的。 APNs如何识别需要推送的设备。 &emsp;&emsp;APNs可以推送给设备Push消息，是因为设备(iPhone、iPad)和APNs有一个长连接的通道。&emsp;&emsp;iOS的Push通道是一个独立的长连接通道，并且是唯一的一个通道，由iOS系统独立维护。也就是说每一个手机系统，每次开机后，手机后台就会发出一个长连接，连接到苹果服务器(APNs)。当APNs收到新的Push通知的时候就会把通知推送给应用设备。 通过官方的原理图四个身份 Provider：我们的服务器sever APNs：苹果服务器 Device(设备)：iPhone、iPad Client App：客户端的app Tip：苹果可以省电省流量，原因之一有Push网络通道是唯一的一个，并且苹果公司来维护。 总结下大致流程 设备打开某个App后，会生成唯一的一个token，并把这个token上传给我们自己的服务器，我们的服务器有了token，就可以向我们的app推送通知了，这个是前提。但是这个通知并不能直接推送给我们的设备，而是要推送给苹果的服务器。 我们的服务器会将token和推送的内容，一起推送给苹果的服务器。 苹果服务器会根据token定位到设备,将push推送给设备。 设备拿到这个push，就会知道是哪个app。然后就可以将这个通知推送到具体的app。 参考资料 push工作原理 苹果官方push内容 iOS远程推送原理及实现过程]]></content>
      <categories>
        <category>iOS</category>
        <category>push</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>push</tag>
      </tags>
  </entry>
</search>
