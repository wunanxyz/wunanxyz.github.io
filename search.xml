<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[知识点：可变数组的属性使用copy修饰的后果]]></title>
    <url>%2F2018%2F11%2F16%2F%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8copy%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%90%8E%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[问题 视频What’s New in LLVM 中，从12:05的时间开始有个关于NSMutableArray可变数组属性的使用问题。 运行后报错图如下： 分析self.photos的实际类型是 __NSMutable0,也就NSArray类型。没有addObject的方法。 进一步探讨 OC是门动态型语言，在编译阶段不会做类型检测。OC的内存管理是引用计数，在ARC环境下，属性@property的内存管理语义关键字有copy,weak,strong,asssin。在编译阶段，默认情况下编译器会生成一个成员变量、一个setter方法、一个getter方法。而在setter方法中，会根据内存管理语义做相应的引用计数相关的操作。当使用copy修饰属性时，在setter中实际操作是拷贝了一份不可变的类型对象。这样的话，即使是其是可变类型，在被赋值后，我们得到的是却是不可变类型的对象。 OC具有多态性，父类可以指向子类。对象最终类型会在运行期根据实例化对象确认。在运行时阶段其isa指向的是[NSArray Class]。那么当向self.photos发送一个addObject消息时，self.photos对象是接收不到这个消息的。因为addObject是NSArray的子类NSMutbleArray的方法。 实际编译器添加setter方法如下：1234// ARC- (void)setPhotos:(NSMutableArray&lt;UIImage *&gt; *)photos&#123; _photos = [photos copy];&#125; 那么得到的是个self.Photos实际是NSArray类。 解决方式一:手动重写setter方法，使用赋值前mutableCopy。如下，这样获取到的就是NSMutableArray类型的对象。123- (void)setPhotos:(NSMutableArray&lt;UIImage *&gt; *)photos&#123; _photos = [photos mutableCopy];&#125; 方式二:使用关键字strong修饰属性。我们得到的依然是可变类型。123- (void)setPhotos:(NSMutableArray&lt;UIImage *&gt; *)photos&#123; _photos = photos;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>OC</category>
        <category>NSMutableArray</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>OC</tag>
        <tag>NSMutableArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSThead的进阶使用和简单探讨]]></title>
    <url>%2F2018%2F11%2F15%2FNSThead%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E5%92%8C%E7%AE%80%E5%8D%95%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[概述NSThread类是一个继承于NSObjct类的轻量级类。一个NSThread对象就代表一个线程。它需要管理线程的生命周期、同步、加锁等问题，因此会产生一定的性能开销。使用NSThread类可以在特定的线程中被调用某个OC方法。当需要执行一个冗长的任务，并且不想让这个任务阻塞应用中的其他部分，尤其为了避免阻塞app的主线程(因为主线程用于处理用户界面展示交互和事件相关的操作),这个时候非常适合使用多线程。线程也可以将一个庞大的任务分为几个较小的任务，从而提高多核计算机的性能。 NSThread类在运行期监听一个线程的语义和NSOperation类是相似的。比如取消一个线程或者决定一个任务执行完后这个线程是否存在。 本文将会从这几个方面开始探讨NSThread 方法属性的介绍初始化(创建)一个NSThread对象123456789// 返回一个初始化的NSThread对象- (instancetype)init// 返回一个带有多个参数的初始化的NSThread对象// selector ：线程执行的方法,最多只能接收一个参数// target ：selector消息发送的对象// argument : 传给selector的唯一参数，也可以是nil- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument );// iOS 10- (instancetype)initWithBlock:(void (^)(void))block; 启动一个线程。 12345678910// 开辟一个新的线程，并且使用特殊的选择器Selector作为线程入口,调用完毕后，会马上创建并开启新线程+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument; // iOS 10+ (void)detachNewThreadWithBlock:(void (^)(void))block;// 启动接受者- (void)start;// 线程体方法，线程主要入口，start 后执行// 该方法默认实现了目标(target)和选择器(selector)，用于初始化接受者和调用指定目标(target)的方法。如果子类化NSThread，需要重写这个方法并且用它来实现这个线程主体。在这种情况下，是不需要调用super方法的。// 不应该直接调用这个方法。你应该通过调用启动方法开启一个线程。- (void)main; 使用initWithTarget:selector:、initWithBlock:、detachNewThreadSelector:，detachNewThreadWithBlock:创建线程都是异步线程。 停止一个线程12345678// 阻塞当前线程，直到特定的时间。+ (void)sleepUntilDate:(NSDate *)date;// 让线程处于休眠状态，直到经过给定的时间间隔+ (void)sleepForTimeInterval:(NSTimeInterval)ti;// 终止当前线程+ (void)exit;// 改变接收者的取消状态，来表示它应该终止- (void)cancel; 决定线程状态123456// 接收者是否存在@property (readonly, getter=isExecuting) BOOL executing;// 接收者是否结束执行@property (readonly, getter=isFinished) BOOL finished;// 接收者是否取消@property (readonly, getter=isCancelled) BOOL cancelled; 主线程相关123456// 当前线程是否是主线程@property (class, readonly) BOOL isMainThread;// 接受者是否是主线程@property (readonly) BOOL isMainThread;// 获取主线程的对象@property (class, readonly, strong) NSThread *mainThread; 执行环境12345678// 这个app是否是多线程+ (BOOL)isMultiThreaded;// 返回当前执行线程的线程对象。@property (class, readonly, strong) NSThread *currentThread;// 返回一个数组，包括回调堆栈返回的地址@property (class, readonly, copy) NSArray&lt;NSNumber *&gt; *callStackReturnAddresses ;// 返回一个数组，包括回调堆栈信号@property (class, readonly, copy) NSArray&lt;NSString *&gt; *callStackSymbols; 线程属性相关12345678// 线程对象的字典@property (readonly, retain) NSMutableDictionary *threadDictionary;NSAssertionHandlerKey// 接收者的名字@property (nullable, copy) NSString *name;// 接收者的对象大小，以byte为单位@property NSUInteger stackSize; 线程优先级12345678// 线程开启后是个只读属性@property NSQualityOfService qualityOfService;// 返回当前线程的优先级+ (double)threadPriority;// 接受者的优先级，已经废弃，使用qualityOfService代替@property double threadPriority;// 设置当前线程的优先级。设置线程的优先级(0.0 - 1.0，1.0最高级)+ (BOOL)setThreadPriority:(double)p; 通知123456// 未被实现，没有实际意义，保留项NSDidBecomeSingleThreadedNotification// 在线程退出前，一个NSThread对象收到到退出消息时会发送这个通知。NSThreadWillExitNotification// 当第一个线程启动时会发送这个通知。这个通知最多发送一次。当NSThread第一次发送用`detachNewThreadSelector:toTarget:withObject:`,`detachNewThreadWithBlock:`,`start`消息时，发送通知。后续调用这些方法是不会发送通知。NSWillBecomeMultiThreadedNotification 线程间通信，在NSObject的分类NSThreadPerformAdditions中的方法(NSThread.h文件中)具有这些特性： 无论是在主线程还是在子线程中都可执行，并且均会调用主线程的aSelector方法； 方法是异步的1234567891011121314151617@interface NSObject (NSThreadPerformAdditions)// 如果设置wait为YES: 等待当前线程执行完以后，主线程才会执行aSelector方法；// 如果设置wait为NO：不等待当前线程执行完，就在主线程上执行aSelector方法。// 如果，当前线程就是主线程，那么aSelector方法会马上执行，wait是YES参数无效。- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;// 等于第一个方法中modes是kCFRunLoopCommonModes的情况。指定了线程中 Runloop 的 Modes = kCFRunLoopCommonModes。- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;// 在指定线程上操作，因为子线程默认未添加NSRunloop，在线程未添加runloop时，是不会调用选择器中的方法的。- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait modes:( NSArray&lt;NSString *&gt; *)array ;// 等于第一个方法中modes是kCFRunLoopCommonModes的情况。- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait ;// 隐式创建子线程,在后台创建。并且是个同步线程。- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg ;@end 直接给接受者发消息的其他方法。 协议NSObject中的方法，可在主线程或者子线程执行。因为是在当前线程执行的同步任务，因此会阻塞当前线程。这几个方法等同于直接调用方法。 1234// 当前线程操作。- (id)performSelector:(SEL)aSelector;- (id)performSelector:(SEL)aSelector withObject:(id)object;- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2; 延迟操作&amp;按照顺序操作 NSRunLoop.h文件中1234567891011121314151617181920212223242526// 延迟操作/**************** Delayed perform ******************/@interface NSObject (NSDelayedPerforming)// 异步方法，不会阻塞当前线程，只能在主线程中执行。是把`Selector`加到主队列里，当 `delay`之后执行`Selector`。如果主线程在执行业务，那只能等到执行完所有业务之后才会去执行`Selector`，就算`delay`等于 0。// 那`delay `从什么时候开始计算呢？从发送`performSelector`消息的时候。就算这时主线程在阻塞也会计算时间，当阻塞结束之后，如果到了`delay`那就执行`Selector`，如果没到就继续 `delay`。// 只能在主线程中执行，在子线程中不会调到aSelector方法- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;// 等于第一个方法中modes是kCFRunLoopCommonModes的情况。指定了线程中 Runloop 的 Modes = kCFRunLoopCommonModes。- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;// 在方法未到执行时间之前，取消方法。调用这2个方法当前target执行dealloc之前，以确保不会Crash。+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget;@end// 按照排序顺序执行@interface NSRunLoop (NSOrderedPerform)// 按某种顺序order执行方法。参数order越小，优先级越高，执行越早// selector都是target的方法，argument都是target的参数// 这2个方法会设置一个定时器去在下个runloop循环的开始时让target执行aSelector消息。 定时器根据modes确认模式。当定时器触发，定时器尝试队列从runloop中拿出消息并执行。如果run loop 正在运行，并且是指定modes的一种，则是成功的，否则定时器一直等待直到runloop是modes 中的一种。- (void)performSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg order:(NSUInteger)order modes:(NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)cancelPerformSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg;- (void)cancelPerformSelectorsWithTarget:(id)target;@end 本文介绍大部分的知识点如思维导图： 使用 创建线程用initXXX初始化的需要调用start方法来启动线程。而detachXXX初始化方法，直接启动线程。这个2中方式创建的线程都是显式创建线程。 1234567891011121314//1. 手动开启，action-target 方式NSThread * actionTargetThread = [[NSThread alloc] initWithTarget:self selector:@selector(add:) object:nil];[actionTargetThread start];//2. 手动开启， block 方式NSThread *blockThread = [[NSThread alloc] initWithBlock:^&#123; NSLog(@&quot;%s&quot;,__func__);&#125;];[blockThread start];//3. 创建就启动， action-target 方式[NSThread detachNewThreadSelector:@selector(add2:) toTarget:self withObject:@&quot;detachNewThreadSelector&quot;];//4. 创建就启动， block 方式[NSThread detachNewThreadWithBlock:^&#123; NSLog(@&quot;%s&quot;,__func__);&#125;]; 线程中通信 2.1 NSThreadPerformAdditions分类方法，异步调用方法// 无论在子线程还是主线程，都会调用主线程方法。 a. 主线程 12[self performSelectorOnMainThread:@selector(add:) withObject:nil waitUntilDone:YES];//[self performSelectorOnMainThread:@selector(add:) withObject:@&quot;arg&quot; waitUntilDone:YES modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]]; 子线程默认没有开启runloop。需要手动添加，不然选择器方法无法调用。 b. 子线程 使用initWithBlock:方式创建。1234567891011//1. 开辟一个子线程NSThread *subThread1 = [[NSThread alloc] initWithBlock:^&#123; // 2.子线程方法中添加runloop // 3.实现线程方法 [[NSRunLoop currentRunLoop] run];&#125;];//1.2. 启动一个子线程[subThread1 start];// 2. 在子线程中调用方法// [self performSelector:@selector(add:) onThread:subThread1 withObject:@&quot;22&quot; waitUntilDone:YES];[self performSelector:@selector(add:) onThread:subThread1 withObject:@&quot;arg&quot; waitUntilDone:YES modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]]; 使用initWithTarget:selector:object:创建。1234567891011// 1. 开辟一个子线程NSThread *subThread2 = [[NSThread alloc] initWithTarget:self selector:@selector(startThread) object:nil];// 1.2 启动一个子线程[subThread2 start];// 3. 在子线程中调用方法// [self performSelector:@selector(add:) onThread:subThread2 withObject:@&quot;22&quot; waitUntilDone:YES];[self performSelector:@selector(add:) onThread:subThread1 withObject:@&quot;arg&quot; waitUntilDone:YES modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]];// 2.子线程方法中添加runloop- (void)startThread&#123; [[NSRunLoop currentRunLoop] run];&#125; c. 后台线程(隐式创建一个线程) 1[self performSelectorInBackground:@selector(add:) withObject:@&quot;arg&quot;]; 2.2 协议NSObject方法创建是的同步任务。1234[NSThread detachNewThreadWithBlock:^&#123; // 直接调用 [self performSelector:@selector(add:) withObject:@&quot;xxx&quot;];&#125;]; 2.3 延迟NSObject分类NSDelayedPerforming方法，添加异步任务，并且是在主线程上执行。1[self performSelector:@selector(add:) withObject:self afterDelay:2]; 2.4 按照顺序操作NSRunLoop分类NSOrderedPerform中的方法12345678[NSThread detachNewThreadWithBlock:^&#123; NSRunLoop *currentRunloop = [NSRunLoop currentRunLoop]; // 记得添加端口。不然无法调用selector方法 [currentRunloop addPort:[NSPort port] forMode:(NSRunLoopMode)kCFRunLoopCommonModes]; [currentRunloop performSelector:@selector(add:) target:self argument:@&quot;arg1&quot; order:1 modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]]; [currentRunloop performSelector:@selector(add:) target:self argument:@&quot;arg3&quot; order:3 modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]]; [currentRunloop run];&#125;]; 线程安全问题： 多个线程可能会同时访问同一块资源。比如多个线程同时访问同一个对象、同一个变量、同一个文件等。当多个线程同时抢夺同一个资源，会引起线程不安全性，可能会造成数据错乱和数据安全问题。 解决： 使用线程同步技术: 可以对可能会被抢夺的资源，在被被竞争的时候加锁。让其保证线程同步状态。而锁具有多种类型：比如读写锁、自旋锁、互斥锁、信号量、条件锁等。在NSThread可能造成资源抢夺情况下，可以使用互斥锁。互斥锁就是多个线程任务按顺序的执行。如下就使用的情况之一：对需要读写操作的资源，进行加锁操作。123456for (NSInteger index = 0 ; index &lt; 100; index ++) &#123; @synchronized (self) &#123; self.allCount -= 5; NSLog(@&quot;%@卖出了车票，还剩%ld&quot;,[NSThread currentThread].name,self.allCount); &#125;&#125; 线程生命周期。线程的生命周期是：新建 - 就绪 - 运行 - 阻塞 - 死亡。当线程启动后，它不能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也就会随之改变。 新建和就绪状态显式创建，使用initWithTarget:selector:和initWithBlock:创建一个线程，未启动，只有发送start消息才会启动，然后处于就行状态。使用detachNewThreadWithBlock:和detachNewThreadSelector:toTarget:显示创建并立即启动。 还有种创建方式，隐式创建并立即启动:performSelectorInBackground:withObject:。 运行和阻塞状态如果处于就绪状态的线程获得了CPU资源，开始执行可执行方法的线程执行体(block或者@Selector)，则该线程处于运行状态。 当发生如下情况下，线程将会进入阻塞状态： 线程调用sleep方法:sleepUntilDate: sleepForTimeInterval:主动放弃所占用的处理器资源。 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。线程试图获得一个同步监视器，但该同步监视器正被其他线程锁持有。 线程在等待某个通知(notify)。 程序调用了线程的suspend方法将该线程挂起。不过这个方法容易导致死锁，所以程序应该尽量避免使用该方法。 当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会了。被阻塞的线程会在合适时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。针对上面的几种情况，当发生如下特定的情况将可以解除上面的阻塞，让该线程重新进入就绪状态： 调用sleep方法的线程经过了指定时间。 线程调用的阻塞式IO方法已经返回。 线程成功地获得了试图取得同步监视器。 线程正在等待某个通知时，其他线程发出了一个通知。 处于挂起状态的线程被调用了resume恢复方法。 线程死亡 可执行方法执行完成，线程正常结束。 程序的意外奔溃。 该线程的发送exit消息来结束该线程。 1234567891011121314151617// 1. 创建：New状态NSThread * actionTargetThread = [[NSThread alloc] initWithTarget:self selector:@selector(add:) object:nil];// 2. 启动：就绪状态[actionTargetThread start];// 可执行方法- (void)add:(id)info&#123; // 3. 执行状态 NSLog(@&quot;%s,info %@&quot;,__func__,info); // 5. 当前线程休眠 [NSThread sleepForTimeInterval:1.0]; NSLog(@&quot;after&quot;); // 4. 程序正常退出&#125;// 6. 打取消标签[actionTargetThread cancel];// 7. 主动退出[NSThread exit]; 注意： NSThread 管理多个线程比较困难,所以不太推荐在多线程任务多的情况下使用。 苹果官方推荐使用GCD和NSOperation。 [NSTread currentThread] 跟踪任务所在线程,适用于NSTread,NSOperation,和GCD 用NSThread创建的线程,不会自动添加autoreleasepool 参考 nsthread apple 文档 线程的生命周期 线程的生命周期及五种基本状态]]></content>
      <categories>
        <category>iOS</category>
        <category>OC</category>
        <category>NSThread</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>OC</tag>
        <tag>NSThread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS缓存策略之NSCache的简单使用]]></title>
    <url>%2F2018%2F11%2F15%2FiOS%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E4%B9%8BNSCache%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[NSCache是一个继承NSObjec的可变集合，是苹果提供的一套缓存机制，用键值(key-value)对来临时存储只需要短暂存储在内存中的数据，并且当内存空间很少的时候会可以自动释放一些资源。 概观缓存(cache)对象和其他可变集合不同的几个方面。 NSCache类包含了各种自动销毁策略，来保证缓存内容没有占用过多的系统内存。如果其他应用需要内存，这些策略会从系统中移除一些选项内容，来减少当前app占用的内存空间。 可以在不同的线程中对内存中的缓存执行添加、移除和查询操作，而不必自己锁住缓存,因为是线程安全的。 不同于NSMutableDictionary对象，缓存使用的key是不需要是实现NSCopying协议的，NSMutableDictionary是非线程安全的，在OC中可变类型一般都是非线程安全的。 NSCache可以指定缓存数量(限额)和一共可用的空间容量，当缓存超出限额或者可用内存容量会自动释放相应内存。 通常使用NSCache对象去临时存储那些创建很昂贵的过渡数据。重用这些数据可以提供性能优势，因为这些值没必要被重新计算。有些数据并非是关键数据，在内存紧张的时候，可以被丢弃。如果丢弃，这些值将会被重新计算。 具有子组件的对象在没有被使用时可以被丢弃，该对象可以采用NSDiscardableContent协议，去提高缓存回收行为。默认情况下。在缓存中的NSDiscardableContent对象丢弃的内容会被自动移出缓存，即使这个自动移除政策是可以修改的。如果一个NSDiscardableContent对象被放进缓存中，那么当该对象被移出时会调用discardContentIfPossible。 使用以下可以使用，从多个方法介绍NSCache。 12// 缓存的名称@property (copy) NSString *name; 设置缓存空间1234// 对象缓存可持有最大的数量 ，默认是0 没有限制），一旦超出限额，会自动删除之前添加的缓存数据@property NSUInteger countLimit;// 缓存中可持有的最大空间 默认是0（没有限制）@property NSUInteger totalCostLimit; 管理丢弃内容1234// 是否可以自动缓存清除可丢弃的内容，默认是YES@property BOOL evictsObjectsWithDiscardedContent;// 可以实现这个协议，当类的对象有可以被销毁不再使用的子组件。这样使用app占用更少的内存空间。NSDiscardableContent 设置代理1234// cache的代理@property (nullable, assign) id&lt;NSCacheDelegate&gt; delegate;// 一个NSCache对象的代理，实现这些协议代理，去将对象从缓存中移除NSCacheDelegate 获取一个缓存值 12// 返回给定key关联的value值- (nullable ObjectType)objectForKey:(KeyType)key; 添加和移除缓存值 12345678// 根据key值设置在缓存中的value值- (void)setObject:(ObjectType)obj forKey:(KeyType)key; // 0 cost// 根据key值设置在缓存中的value值，并且指定关联key-value对的成本- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;// 根据key值移除在缓存的value值- (void)removeObjectForKey:(KeyType)key;// 清空全部缓存，调用次方法依然可以添加新值，网上很多复制粘贴的博客，都说调用次方法后不能添加，亲测是可以的。- (void)removeAllObjects; NSCacheDelegate 方法1234567@protocol NSCacheDelegate &lt;NSObject&gt;@optional// 回收内存空间使用。// cache 缓存对象。// obj 被回收的对象。- (void)cache:(NSCache *)cache willEvictObject:(id)obj;@end 在NSObject.h中的可以废弃内容。12345678910111213/*********** Discardable Content ***********/@protocol NSDiscardableContent@required- (BOOL)beginContentAccess;- (void)endContentAccess;- (void)discardContentIfPossible;- (BOOL)isContentDiscarded;@end@interface NSObject (NSDiscardableContentProxy)@property (readonly, retain) id autoContentAccessingProxy;@end 使用 初始化对象 1234567891011// 1. 初始化数据- (NSCache *)mainCache&#123; if (!_mainCache) &#123; _mainCache = [[NSCache alloc] init]; _mainCache.countLimit = 300; // 限制个数，默认是0，无限空间 _mainCache.totalCostLimit = 5*1024*1024; // 设置大小设置，默认是0，无限空间 _mainCache.name = @&quot;cache1&quot;; _mainCache.delegate = self; &#125; return _mainCache;&#125; 添加缓存 12// 添加缓存 [self.mainCache setObject:data forKey:str]; 移除。在内存警告的时候（didReceiveMemoryWarning）移除缓存。给对象发送removeAllObjects，后添加缓存setObject:forKey:是可以的，可以再添加进去的。还有一个根据key移除对应的值。 12[self.mainCache removeAllObjects];//[self.mainCache removeObjectForKey:@&quot;XXX&quot;]; 代理在当前对象遵守NSCacheDelegate协议。并且实现协议。并且让当前对象成为代理_mainCache.delegate = self; 123- (void)cache:(NSCache *)cache willEvictObject:(id)obj&#123; NSLog(@&quot;%s&quot;,__func__);&#125; 推荐 Apple NSCache 文档]]></content>
      <categories>
        <category>iOS</category>
        <category>OC</category>
        <category>NSCache</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>OC</tag>
        <tag>NSCache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点：id和NSObject *对比，以及id 介绍]]></title>
    <url>%2F2018%2F11%2F06%2Fid-NSObject%2F</url>
    <content type="text"><![CDATA[在obj.h的类文件中，可以看出id类型和NSObject类型的信息。如下： 类 id12345678/// An opaque type(隐含类型) that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa ;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 类 NSObject123@interface NSObject &lt;NSObject&gt; &#123; Class isa ;&#125; 协议 NSObject12@protocol NSObject@end 类 NSProxy123@interface NSProxy &lt;NSObject&gt; &#123; Class isa;&#125; id和NSObject对比 从上面的源码可以看出，id是struct objc_object结构体指针,可以指向任何OC对象，当然不包括NSInteger等，因为这些数据类型不是OC对象。另外OC的基类，其实不仅仅就NSObject一个，虽然NSObject是绝大数OC对象的基类，但是还有个NSProxy虚类。所以不能说id类型和NSObject *是等价的。 id类型的实例在编译阶段不会做类型检测，会在运行时确定，所以id类型是运行时的动态类型。类NSObject的实例会编译期要做编译检查，保证指针指向是其NSObject类或其子类，当然实例的具体类型要在运行期确定，这也是iOS的多态的体现。 id指针的会有局限性：调用方法,只能使用中括弧，不能使用点语法。 id \ 是什么呢？这里的NSObject是协议NSObject(protocol)而非类NSObject。所以这里表示是遵守协议NSObject的所以类。另外NSObject类和NSProxy类都是实现了协议NSObject。 不错的推荐： oc runtime源码 版本 objc4-723]]></content>
      <categories>
        <category>iOS</category>
        <category>OC</category>
        <category>id</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>OC</tag>
        <tag>id</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOSBug:The operation couldn’t be completed. (DVTCoreSimulatorAdditionsErrorDomain error 0.)]]></title>
    <url>%2F2018%2F10%2F29%2FiOS%E6%A8%A1%E6%8B%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言查看磁盘空间的时候，发现系统磁盘消耗太多空间。而且显示是系统消耗的。然后就大举的删除了很多关了XCode和模拟器本地资源。然后运行XCode。发现模拟器一直调不出来，并且XCode提示这个错误，如下 The operation couldn’t be completed. (DVTCoreSimulatorAdditionsErrorDomain error 0.) 解决方案：重新启动mac]]></content>
      <categories>
        <category>iOS</category>
        <category>bug</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4异常处理Try_Catch的使用之初见]]></title>
    <url>%2F2018%2F10%2F26%2FSwift4%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86Try-Catch%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%88%9D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[前言从OC转Swift了。虽然Swift的官方语法的资料看了2遍了。还是在使用的时候遇到点问题。好记性，不如烂笔头。本篇不是高深的内容。只是作为初使用的记录。 当想给一个函数使用try-catch。需要在函数后加个throws。具体使用，如下先有个错误的枚举1234enum ErrorType:Error&#123; case ErrorTypeNil case ErrorType1&#125; 这里需要函数出错会抛出错误的情况，记住后面要加throws。 123456789func largerThanEighteenthFunc(a:Int16?) throws &#123; if let need = a ,need &gt;= 18&#123; print("need &gt;&gt;&gt;&gt; \(need)") throw ErrorType.ErrorTypeNil &#125;else&#123; print("need &lt;=18") throw ErrorType.ErrorType1 &#125;&#125; 不需要捕抓错误，可以使用try!或try?。但是不建议不建议使用try!，使用try?会更加安全。因为如果当有错误捕抓到时，程序会直接崩溃123func notPrintError() &#123; try? largerThanEighteenthFunc(a: nil) &#125; 如果只包含一个catch语句，那么所有的错误都会在这个catch中执行，能够捕抓其错误信息 1234567func oneCondition() &#123; do &#123; try largerThanEighteenthFunc(a: 9) &#125; catch let error &#123; print("error &gt;&gt;&gt; \(error)") &#125; &#125; 在使用catch时，我们想它是能够进行模式匹配的、能够进行更精准的错误匹配处理。可以穷举多种情况。12345678910func twoCondition() &#123; do &#123; try largerThanEighteenthFunc(a: 20) &#125; catch ErrorType.ErrorTypeNil &#123; print(ErrorType.ErrorTypeNil) &#125; catch ErrorType.ErrorType1 &#123; print(ErrorType.ErrorType1) &#125; catch &#123; // 加入一个空的catch，用于关闭catch。否则会报错：Errors thrown from here are not handled because the enclosing catch is not exhaustive &#125;&#125; 注意：在使用do-catch的时候。无论是不是把错误都穷举完，一定要写个空catch，不然会报错。这个错误就是 Errors thrown from here are not handled because the enclosing catch is not exhaustive 友情连接： 本文代码的github地址]]></content>
      <categories>
        <category>Swift</category>
        <category>try_catch</category>
      </categories>
      <tags>
        <tag>Swift - try_catch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift代理协议的安全使用]]></title>
    <url>%2F2018%2F10%2F25%2FSwift%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[文章Swift代理协议的安全使用 概述在Swift下，使用代理协议，并且检验代理对象的存在和协议函数是否被实现。 前言可空链式调用（Optional Chaining）是一种可以请求和调用属性、方法及下标的过程，它的可空性体现于请求或调用的目标当前可能为空（nil）。如果可空的目标有值，那么调用就会成功；如果选择的目标为空（nil），那么这种调用将返回空（nil）。多个连续的调用可以被链接在一起形成一个调用链，如果其中任何一个节点为空（nil）将导致整个链调用失败。 注意： Swift 的可空链式调用和 Objective-C 中的消息为空有些相像，但是 Swift 可以使用在任意类型中，并且能够检查调用是否成功。 空链式（Optional Chaining）的使用之一在Swift中空链式的有个实用例子，就是编写代理的时候。当触发协议方法的时候，因为OC是消息型语言，所以必须要判断这个实例是否存在并且要判断当前方法是否被实现，不然没有实现的话，Runtime期间，就可能会报错。又因为OC几乎所以的类都是继承基类NSObject，而根类NSObject实现了其协议NSObject的协议方法respondsToSelector:,该方法可以判断某个方法实现的。如下 1234// 判断添加了代理对象，并且该对象实现了某个协议方法if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(protocalMethod)]) &#123; [self.delegate protocalMethod];&#125; 而在Swift语言中，并未要求继承某个根类。并且也未提供某个方法去不判断某个方法是否被实现。其实因为Swift的语言一个特性–可选性，就很好解决这些问题了。正如上方的描述，如果其中任何一个节点为空（nil）将导致整个链调用失败。如下1self.delegate?.SwiftProtocolTest?() 当判读使用有代理对象的时候，只需在属性delegate添加”?”就行，而需要判断某个函数是否实现只需在函数名和()之间添加”?”就行。 提示：本文delegate在Swift和OC的对比可以查看 github 代码 友情提示： Apple-optional文档 using_delegates_to_customize_object_behavior]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
        <category>delegate</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>delegate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发环境下PP文件的创建]]></title>
    <url>%2F2018%2F10%2F23%2F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8BPP%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[开发环境下Provisioning Profile文件的创建。当我们在做iOS开发的时候,总是添加很多证书，来保证安全性。Provisioning Profile我们又称PP文件。这个文件将证书、App Id和设备相关联。本章节就是教大家如何创建开发环境下的PP文件。 通过该Certificates,Identifiers&amp;Profiles–&gt; Provisioning Profiles–&gt; Development路径，找到Profile文件的列表页面。添加+准备添加新的PP文件。 2.选择证书的类型，这里选择开发证书。 3.选择APPID&amp;证书&amp;设备。 3.1 选择对应的 APP ID 3.2 选择对应的证书 3.3 选择可以安装软件的设备号，设备号也就是每个硬件设备的序列号。 填写这个PP文件的名称。 走到这步，说明已经安装成功。点击按钮Download就可以下载了。 over，是不是很简单。正式环境的PP文件，也是大同小异。有时间也出篇教程。]]></content>
      <categories>
        <category>iOS</category>
        <category>PP文件</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>PP文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发实用软件之NWPusher]]></title>
    <url>%2F2018%2F10%2F23%2FiOS%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%B9%8BNWPusher%2F</url>
    <content type="text"><![CDATA[一个App获取到一个Push内容。必须是服务器拿着对应token和需要的消息内容发给苹果服务器，然后由苹果服务器推送给用户。作为前端开发人员，为了学习Push，去搭建一个服务器，还是很耗时的。想了解iOS推送系列之Push的工作原理，可以查看这篇博客。 现在有个软件NWPusher可以模拟服务器发送Push。为我们研究Push提供了便利，我们一起来了解下。 一、软件的安装多种方式： 使用Homebrew cask 1brew cask install pusher 直接安装Pusher.app 可以下载软件：最新的下载地址 NWPusher可以可以当做framework使用。这个也有2种方式。 3.1 使用CocoaPods 1pod &apos;NWPusher&apos;, &apos;~&gt; 0.7.0&apos; 3.2 使用Carthage 1github &quot;noodlewerk/NWPusher&quot; 二、软件的介绍软件界面如图：如图所示： 我们需要选择相应的Push开发测试证书，如果创建证书，可以查看开发环境Push证书的创建图文流程这篇博客了解相应的知识。 添加相应的deviceToken 选择过期时间:有8种选择。 Expiry:None : 不会过期 immediate(0) :立即 1 minute :1分钟时 5 minutes :5分钟时 1 hour :1小时时 1 day :1天时 Far past(1) :遥远的过去 Far future: :永远 选择优先级：3个 Pirority:None :没有优先级 Conserve power(5) : 电量优先 immediately(10) : 立刻，其优先级最高 Payload输入内容就是我们需要传送的数据了：这个数据传输以JSON的格式存储。是必要按照APNs发送的Push格式的。Push消息常用的key如下： aps,是其value是我们需要传送的内容。 alert,是其value就是弹出框需要展示的内容。 badge,是其value就是APP icon，展示的信息个数。 sound,是其value就是表示当有Push消息的时候，是否需要声音提示。 另外，alert中value值，可以是字符串，可以是字典。这个字典可以使用多对值，比如其key是title,subtitle,body等。其格式如下1234567891011&#123; "aps": &#123; "alert": &#123; "title": "title", "subtitle": "subTitle", "body": "body" &#125;, "badge": 1, "sound": "default" &#125;&#125; 更多关于aps,alert,sound等可以查看官网：Generating a Remote Notification 所以都填选好，点击按钮 Push。就可以发送了。其发送状态，边上都有发布状态的提示信息。 友情链接： Generating a Remote Notification NWPusher github地址 搭建Push环境]]></content>
      <categories>
        <category>iOS</category>
        <category>push</category>
      </categories>
      <tags>
        <tag>push</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发环境Push证书的创建图文流程]]></title>
    <url>%2F2018%2F10%2F22%2F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83Push%E8%AF%81%E4%B9%A6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%9B%BE%E6%96%87%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[当写Push的时候，必须有相应的证书。而证书的创建也是个知识点。今天以图文的形式写个相关的证书创建的流程。生成对应的APP ID 和证书 一.添加App ID1.进入苹果开发中心的App Id 选择 Cerfificates,Identifiers&amp;Profiles –&gt; Identifiers –&gt; App IDs 点击右上角的+来添加证书。 2.注册一个App ID 在这个页面填写和选择相应的 在App ID Description –&gt; name 输入相应的App Name 在App ID Suffix –&gt; Explicit App ID –&gt; Bundle ID 输入相应的bundle id 在 App Services –&gt; Enable Services 选择相应的服务。这里选项 Push Notifications。点击continue生成对应的app id 3. 确认App Id，这个页面不需要填选任何内容。检查下即将创建的App ID的内容，是否正确。 点击Rigister注册。 4. 完成操作点击Done完成操作。这个时候App ID就创建成功了。 生成APP ID 之后，再生成对应的证书，用于身份认证。 二. 进入苹果开发中心的证书1. 进入开发环境证书列表页 选择 Cerfificates,Identifiers&amp;Profiles –&gt; Cerfificates –&gt; Development 点击右上角的+来添加证书。 2. 选择证书类型2.1. 因为是需要添加推送证书，选择的证书了类型Apple Push Notification server SSL(SandBox)。然后下一步 2.2. 选择添加App Id 3. 提交点子信息证书的请求相应证书创建电子信息证书步骤是提示,点击continue. 4. 生成选择添加本地请求文件。如何创建请求文件，从下面的第三部分：创建电子信息证书的步骤获取。 5. 下载证书已经生成成功，下载到本地。 6. 添加到钥匙串下载的文件aps_development.cer,双击这个文件来安装。安装成功就会跳转到钥匙串的证书部分，表示安装成功。 三. 电子证书请求文件的创建。 在进入钥匙串中 创建电子签名请求 a. 钥匙串访问 –&gt; 证书助理 –&gt; 从证书颁发机构请求... b. 填写添加邮件,选择存储到磁盘。点击继续,选择保存到本地的位置，保存到本地。c.本地的电子签名请求 以上就是整个开发环境Push证书的创建过程。 参考: 搭建Push环境上]]></content>
      <categories>
        <category>iOS</category>
        <category>push</category>
        <category>证书</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>push</tag>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中Class和Struct异同]]></title>
    <url>%2F2018%2F10%2F17%2FSwift%E4%B8%ADClass%E5%92%8CStruct%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[Swift 中类和结构体有很多共同点。共同处在于： 定义属性用于存储值 定义方法用于提供功能 定义下标操作使得可以通过下标语法来访问实例所包含的值 定义构造器用于生成初始化值 通过扩展以增加默认实现的功能 实现协议以提供某种标准功能 与结构体相比，类还有如下的附加功能： 继承允许一个类继承另一个类的特征 类型转换允许在运行时检查和解释一个类实例的类型 析构器允许一个类实例释放任何其所被分配的资源 引用计数允许对一个类的多次引用 Tip: 类的对象是引用类型，而结构体是值类型。所以类的赋值是传递引用，结构体则是Copy传值,不是使用引用计数。 类为支持的额外功能会增加其复杂性。一般,更倾向使用选择结构和枚举,因为他们更容易理解,而类，则当再在合适和必要的时候使用。实际上,这意味着大多数的自定义数据类型定义为结构和枚举就可以了。更详细的比较,请参阅结构和类之间的选择。 定义语法类和结构体有着类似的定义方式。我们通过关键字class和struct来分别表示类和结构体，并在一对大括号中定义它们的具体内容： 123456class SomeClass &#123; // 在这里定义类&#125;struct SomeStructure &#123; // 在这里定义结构体&#125; 注意 在定义一个新类或者结构体的时候，实际上是定义了一个新的 Swift 类型。因此请使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），以便符合标准 Swift 类型的大写命名风格（如String，Int和Bool）。相反的，请使用lowerCamelCase这种方式为属性和方法命名（如framerate和incrementCount），以便和类型名区分。 以下是定义结构体和定义类的示例：1234567891011struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?&#125; 类和结构体实例生成结构体和类实例的语法非常相似：12let someResolution = Resolution()let someVideoMode = VideoMode() 结构体和类都使用构造器语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如Resolution()或VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。 属性访问通过使用点语法,访问实例的属性.12print("The width of someResolution is \(someResolution.width)")// 打印 "The width of someResolution is 0" 可以访问子属性12print("The width of someVideoMode is \(someVideoMode.resolution.width)")// 打印 "The width of someVideoMode is 0" 可以使用点语法为变量属性赋值123someVideoMode.resolution.width = 1280print("The width of someVideoMode is now \(someVideoMode.resolution.width)")// 打印 "The width of someVideoMode is now 1280" 结构体类型的成员逐一构造器所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：1let vga = Resolution(width:640, height: 480) 与结构体不同，类实例没有默认的成员逐一构造器。 结构体和枚举是值类型值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。 实际上，在Swift中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。 在Swift中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。 类是引用类型与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。 恒等运算符因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符： 等价于（===） 不等价于（!==） 运用这两个运算符检测两个常量或者变量是否引用同一个实例： 1234if tenEighty === alsoTenEighty &#123; print("tenEighty and alsoTenEighty refer to the same Resolution instance.")&#125;//打印 "tenEighty and alsoTenEighty refer to the same Resolution instance." 请注意，“等价于”（用三个等号表示，===）与“等于”（用两个等号表示，==）的不同： “等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。 “等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法。 指针C，C++ 或者Objective-C语言使用指针来引用内存中的地址。一个引用某个引用类型实例的 Swift 常量或者变量，与C语言中的指针类似，但是并不直接指向某个内存地址，也不要求你使用星号（*）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。 类和结构体的选择结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。 按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体： 该数据结构的主要目的是用来封装少量相关简单数据值。 有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。 该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。 该数据结构不需要去继承另一个既有类型的属性或者行为。 举例来说，以下情境中适合使用结构体： 几何形状的大小，封装一个width属性和height属性，两者均为Double类型。 一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。 三维坐标系内一点，封装x，y和z属性，三者均为Double类型。 在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。 字符串、数组、和字典类型的赋值与复制行为Swift中，所以基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。 Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。 注意以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。 参考： 苹果 swift - Structures and Classes 中文翻译类与结构体]]></content>
      <categories>
        <category>Swift</category>
        <category>Class</category>
        <category>Struct</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS推送系列之Push的工作原理]]></title>
    <url>%2F2018%2F10%2F17%2FPrincipleOfPush%2F</url>
    <content type="text"><![CDATA[Push的工作原理 要理解Push的工作原理，我们必须要知道几个知识点。 设备是如何和APNs保持连接的。 APNs如何识别需要推送的设备。 &emsp;&emsp;APNs可以推送给设备Push消息，是因为设备(iPhone、iPad)和APNs有一个长连接的通道。&emsp;&emsp;iOS的Push通道是一个独立的长连接通道，并且是唯一的一个通道，由iOS系统独立维护。也就是说每一个手机系统，每次开机后，手机后台就会发出一个长连接，连接到苹果服务器(APNs)。当APNs收到新的Push通知的时候就会把通知推送给应用设备。 通过官方的原理图四个身份 Provider：我们的服务器sever APNs：苹果服务器 Device(设备)：iPhone、iPad Client App：客户端的app Tip：苹果可以省电省流量，原因之一有Push网络通道是唯一的一个，并且苹果公司来维护。 总结下大致流程 设备打开某个App后，会生成唯一的一个token，并把这个token上传给我们自己的服务器，我们的服务器有了token，就可以向我们的app推送通知了，这个是前提。但是这个通知并不能直接推送给我们的设备，而是要推送给苹果的服务器。 我们的服务器会将token和推送的内容，一起推送给苹果的服务器。 苹果服务器会根据token定位到设备,将push推送给设备。 设备拿到这个push，就会知道是哪个app。然后就可以将这个通知推送到具体的app。 参考资料 push工作原理 苹果官方push内容 iOS远程推送原理及实现过程]]></content>
      <categories>
        <category>iOS</category>
        <category>push</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>push</tag>
      </tags>
  </entry>
</search>
