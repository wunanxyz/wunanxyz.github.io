<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOSBug:The operation couldn’t be completed. (DVTCoreSimulatorAdditionsErrorDomain error 0.)]]></title>
    <url>%2F2018%2F10%2F29%2FiOS%E6%A8%A1%E6%8B%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言查看磁盘空间的时候，发现系统磁盘消耗太多空间。而且显示是系统消耗的。然后就大举的删除了很多关了XCode和模拟器本地资源。然后运行XCode。发现模拟器一直调不出来，并且XCode提示这个错误，如下 The operation couldn’t be completed. (DVTCoreSimulatorAdditionsErrorDomain error 0.) 解决方案：重新启动mac]]></content>
      <categories>
        <category>iOS</category>
        <category>bug</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift4异常处理Try_Catch的使用之初见]]></title>
    <url>%2F2018%2F10%2F26%2FSwift4%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86Try-Catch%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%88%9D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[前言从OC转Swift了。虽然Swift的官方语法的资料看了2遍了。还是在使用的时候遇到点问题。好记性，不如烂笔头。本篇不是高深的内容。只是作为初使用的记录。 当想给一个函数使用try-catch。需要在函数后加个throws。具体使用，如下先有个错误的枚举1234enum ErrorType:Error&#123; case ErrorTypeNil case ErrorType1&#125; 这里需要函数出错会抛出错误的情况，记住后面要加throws。 123456789func largerThanEighteenthFunc(a:Int16?) throws &#123; if let need = a ,need &gt;= 18&#123; print("need &gt;&gt;&gt;&gt; \(need)") throw ErrorType.ErrorTypeNil &#125;else&#123; print("need &lt;=18") throw ErrorType.ErrorType1 &#125;&#125; 不需要捕抓错误，可以使用try!或try?。但是不建议不建议使用try!，使用try?会更加安全。因为如果当有错误捕抓到时，程序会直接崩溃123func notPrintError() &#123; try? largerThanEighteenthFunc(a: nil) &#125; 如果只包含一个catch语句，那么所有的错误都会在这个catch中执行，能够捕抓其错误信息 1234567func oneCondition() &#123; do &#123; try largerThanEighteenthFunc(a: 9) &#125; catch let error &#123; print("error &gt;&gt;&gt; \(error)") &#125; &#125; 在使用catch时，我们想它是能够进行模式匹配的、能够进行更精准的错误匹配处理。可以穷举多种情况。12345678910func twoCondition() &#123; do &#123; try largerThanEighteenthFunc(a: 20) &#125; catch ErrorType.ErrorTypeNil &#123; print(ErrorType.ErrorTypeNil) &#125; catch ErrorType.ErrorType1 &#123; print(ErrorType.ErrorType1) &#125; catch &#123; // 加入一个空的catch，用于关闭catch。否则会报错：Errors thrown from here are not handled because the enclosing catch is not exhaustive &#125;&#125; 注意：在使用do-catch的时候。无论是不是把错误都穷举完，一定要写个空catch，不然会报错。这个错误就是 Errors thrown from here are not handled because the enclosing catch is not exhaustive 友情连接： 本文代码的github地址]]></content>
      <categories>
        <category>Swift</category>
        <category>try_catch</category>
      </categories>
      <tags>
        <tag>Swift - try_catch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift代理协议的安全使用]]></title>
    <url>%2F2018%2F10%2F25%2FSwift%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[文章Swift代理协议的安全使用 概述在Swift下，使用代理协议，并且检验代理对象的存在和协议函数是否被实现。 前言可空链式调用（Optional Chaining）是一种可以请求和调用属性、方法及下标的过程，它的可空性体现于请求或调用的目标当前可能为空（nil）。如果可空的目标有值，那么调用就会成功；如果选择的目标为空（nil），那么这种调用将返回空（nil）。多个连续的调用可以被链接在一起形成一个调用链，如果其中任何一个节点为空（nil）将导致整个链调用失败。 注意： Swift 的可空链式调用和 Objective-C 中的消息为空有些相像，但是 Swift 可以使用在任意类型中，并且能够检查调用是否成功。 空链式（Optional Chaining）的使用之一在Swift中空链式的有个实用例子，就是编写代理的时候。当触发协议方法的时候，因为OC是消息型语言，所以必须要判断这个实例是否存在并且要判断当前方法是否被实现，不然没有实现的话，Runtime期间，就可能会报错。又因为OC几乎所以的类都是继承基类NSObject，而根类NSObject实现了其协议NSObject的协议方法respondsToSelector:,该方法可以判断某个方法实现的。如下 1234// 判断添加了代理对象，并且该对象实现了某个协议方法if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(protocalMethod)]) &#123; [self.delegate protocalMethod];&#125; 而在Swift语言中，并未要求继承某个根类。并且也未提供某个方法去不判断某个方法是否被实现。其实因为Swift的语言一个特性–可选性，就很好解决这些问题了。正如上方的描述，如果其中任何一个节点为空（nil）将导致整个链调用失败。如下1self.delegate?.SwiftProtocolTest?() 当判读使用有代理对象的时候，只需在属性delegate添加”?”就行，而需要判断某个函数是否实现只需在函数名和()之间添加”?”就行。 提示：本文delegate在Swift和OC的对比可以查看 github 代码 友情提示： Apple-optional文档 using_delegates_to_customize_object_behavior]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
        <category>delegate</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>delegate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发环境下PP文件的创建]]></title>
    <url>%2F2018%2F10%2F23%2F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8BPP%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[开发环境下Provisioning Profile文件的创建。当我们在做iOS开发的时候,总是添加很多证书，来保证安全性。Provisioning Profile我们又称PP文件。这个文件将证书、App Id和设备相关联。本章节就是教大家如何创建开发环境下的PP文件。 通过该Certificates,Identifiers&amp;Profiles–&gt; Provisioning Profiles–&gt; Development路径，找到Profile文件的列表页面。添加+准备添加新的PP文件。 2.选择证书的类型，这里选择开发证书。 3.选择APPID&amp;证书&amp;设备。 3.1 选择对应的 APP ID 3.2 选择对应的证书 3.3 选择可以安装软件的设备号，设备号也就是每个硬件设备的序列号。 填写这个PP文件的名称。 走到这步，说明已经安装成功。点击按钮Download就可以下载了。 over，是不是很简单。正式环境的PP文件，也是大同小异。有时间也出篇教程。]]></content>
      <categories>
        <category>iOS</category>
        <category>PP文件</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>PP文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发实用软件之NWPusher]]></title>
    <url>%2F2018%2F10%2F23%2FiOS%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%B9%8BNWPusher%2F</url>
    <content type="text"><![CDATA[一个App获取到一个Push内容。必须是服务器拿着对应token和需要的消息内容发给苹果服务器，然后由苹果服务器推送给用户。作为前端开发人员，为了学习Push，去搭建一个服务器，还是很耗时的。想了解iOS推送系列之Push的工作原理，可以查看这篇博客。 现在有个软件NWPusher可以模拟服务器发送Push。为我们研究Push提供了便利，我们一起来了解下。 一、软件的安装多种方式： 使用Homebrew cask 1brew cask install pusher 直接安装Pusher.app 可以下载软件：最新的下载地址 NWPusher可以可以当做framework使用。这个也有2种方式。 3.1 使用CocoaPods 1pod &apos;NWPusher&apos;, &apos;~&gt; 0.7.0&apos; 3.2 使用Carthage 1github &quot;noodlewerk/NWPusher&quot; 二、软件的介绍软件界面如图：如图所示： 我们需要选择相应的Push开发测试证书，如果创建证书，可以查看开发环境Push证书的创建图文流程这篇博客了解相应的知识。 添加相应的deviceToken 选择过期时间:有8种选择。 Expiry:None : 不会过期 immediate(0) :立即 1 minute :1分钟时 5 minutes :5分钟时 1 hour :1小时时 1 day :1天时 Far past(1) :遥远的过去 Far future: :永远 选择优先级：3个 Pirority:None :没有优先级 Conserve power(5) : 电量优先 immediately(10) : 立刻，其优先级最高 Payload输入内容就是我们需要传送的数据了：这个数据传输以JSON的格式存储。是必要按照APNs发送的Push格式的。Push消息常用的key如下： aps,是其value是我们需要传送的内容。 alert,是其value就是弹出框需要展示的内容。 badge,是其value就是APP icon，展示的信息个数。 sound,是其value就是表示当有Push消息的时候，是否需要声音提示。 另外，alert中value值，可以是字符串，可以是字典。这个字典可以使用多对值，比如其key是title,subtitle,body等。其格式如下1234567891011&#123; "aps": &#123; "alert": &#123; "title": "title", "subtitle": "subTitle", "body": "body" &#125;, "badge": 1, "sound": "default" &#125;&#125; 更多关于aps,alert,sound等可以查看官网：Generating a Remote Notification 所以都填选好，点击按钮 Push。就可以发送了。其发送状态，边上都有发布状态的提示信息。 友情链接： Generating a Remote Notification NWPusher github地址 搭建Push环境]]></content>
      <categories>
        <category>iOS</category>
        <category>push</category>
      </categories>
      <tags>
        <tag>push</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发环境Push证书的创建图文流程]]></title>
    <url>%2F2018%2F10%2F22%2F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83Push%E8%AF%81%E4%B9%A6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%9B%BE%E6%96%87%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[当写Push的时候，必须有相应的证书。而证书的创建也是个知识点。今天以图文的形式写个相关的证书创建的流程。生成对应的APP ID 和证书 一.添加App ID1.进入苹果开发中心的App Id 选择 Cerfificates,Identifiers&amp;Profiles –&gt; Identifiers –&gt; App IDs 点击右上角的+来添加证书。 2.注册一个App ID 在这个页面填写和选择相应的 在App ID Description –&gt; name 输入相应的App Name 在App ID Suffix –&gt; Explicit App ID –&gt; Bundle ID 输入相应的bundle id 在 App Services –&gt; Enable Services 选择相应的服务。这里选项 Push Notifications。点击continue生成对应的app id 3. 确认App Id，这个页面不需要填选任何内容。检查下即将创建的App ID的内容，是否正确。 点击Rigister注册。 4. 完成操作点击Done完成操作。这个时候App ID就创建成功了。 生成APP ID 之后，再生成对应的证书，用于身份认证。 二. 进入苹果开发中心的证书1. 进入开发环境证书列表页 选择 Cerfificates,Identifiers&amp;Profiles –&gt; Cerfificates –&gt; Development 点击右上角的+来添加证书。 2. 选择证书类型2.1. 因为是需要添加推送证书，选择的证书了类型Apple Push Notification server SSL(SandBox)。然后下一步 2.2. 选择添加App Id 3. 提交点子信息证书的请求相应证书创建电子信息证书步骤是提示,点击continue. 4. 生成选择添加本地请求文件。如何创建请求文件，从下面的第三部分：创建电子信息证书的步骤获取。 5. 下载证书已经生成成功，下载到本地。 6. 添加到钥匙串下载的文件aps_development.cer,双击这个文件来安装。安装成功就会跳转到钥匙串的证书部分，表示安装成功。 三. 电子证书请求文件的创建。 在进入钥匙串中 创建电子签名请求 a. 钥匙串访问 –&gt; 证书助理 –&gt; 从证书颁发机构请求... b. 填写添加邮件,选择存储到磁盘。点击继续,选择保存到本地的位置，保存到本地。c.本地的电子签名请求 以上就是整个开发环境Push证书的创建过程。 参考: 搭建Push环境上]]></content>
      <categories>
        <category>iOS</category>
        <category>push</category>
        <category>证书</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>push</tag>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中Class和Struct异同]]></title>
    <url>%2F2018%2F10%2F17%2FSwift%E4%B8%ADClass%E5%92%8CStruct%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[Swift 中类和结构体有很多共同点。共同处在于： 定义属性用于存储值 定义方法用于提供功能 定义下标操作使得可以通过下标语法来访问实例所包含的值 定义构造器用于生成初始化值 通过扩展以增加默认实现的功能 实现协议以提供某种标准功能 与结构体相比，类还有如下的附加功能： 继承允许一个类继承另一个类的特征 类型转换允许在运行时检查和解释一个类实例的类型 析构器允许一个类实例释放任何其所被分配的资源 引用计数允许对一个类的多次引用 Tip: 类的对象是引用类型，而结构体是值类型。所以类的赋值是传递引用，结构体则是Copy传值,不是使用引用计数。 类为支持的额外功能会增加其复杂性。一般,更倾向使用选择结构和枚举,因为他们更容易理解,而类，则当再在合适和必要的时候使用。实际上,这意味着大多数的自定义数据类型定义为结构和枚举就可以了。更详细的比较,请参阅结构和类之间的选择。 定义语法类和结构体有着类似的定义方式。我们通过关键字class和struct来分别表示类和结构体，并在一对大括号中定义它们的具体内容： 123456class SomeClass &#123; // 在这里定义类&#125;struct SomeStructure &#123; // 在这里定义结构体&#125; 注意 在定义一个新类或者结构体的时候，实际上是定义了一个新的 Swift 类型。因此请使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），以便符合标准 Swift 类型的大写命名风格（如String，Int和Bool）。相反的，请使用lowerCamelCase这种方式为属性和方法命名（如framerate和incrementCount），以便和类型名区分。 以下是定义结构体和定义类的示例：1234567891011struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?&#125; 类和结构体实例生成结构体和类实例的语法非常相似：12let someResolution = Resolution()let someVideoMode = VideoMode() 结构体和类都使用构造器语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如Resolution()或VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。 属性访问通过使用点语法,访问实例的属性.12print("The width of someResolution is \(someResolution.width)")// 打印 "The width of someResolution is 0" 可以访问子属性12print("The width of someVideoMode is \(someVideoMode.resolution.width)")// 打印 "The width of someVideoMode is 0" 可以使用点语法为变量属性赋值123someVideoMode.resolution.width = 1280print("The width of someVideoMode is now \(someVideoMode.resolution.width)")// 打印 "The width of someVideoMode is now 1280" 结构体类型的成员逐一构造器所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：1let vga = Resolution(width:640, height: 480) 与结构体不同，类实例没有默认的成员逐一构造器。 结构体和枚举是值类型值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。 实际上，在Swift中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。 在Swift中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。 类是引用类型与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。 恒等运算符因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符： 等价于（===） 不等价于（!==） 运用这两个运算符检测两个常量或者变量是否引用同一个实例： 1234if tenEighty === alsoTenEighty &#123; print("tenEighty and alsoTenEighty refer to the same Resolution instance.")&#125;//打印 "tenEighty and alsoTenEighty refer to the same Resolution instance." 请注意，“等价于”（用三个等号表示，===）与“等于”（用两个等号表示，==）的不同： “等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。 “等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法。 指针C，C++ 或者Objective-C语言使用指针来引用内存中的地址。一个引用某个引用类型实例的 Swift 常量或者变量，与C语言中的指针类似，但是并不直接指向某个内存地址，也不要求你使用星号（*）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。 类和结构体的选择结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。 按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体： 该数据结构的主要目的是用来封装少量相关简单数据值。 有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。 该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。 该数据结构不需要去继承另一个既有类型的属性或者行为。 举例来说，以下情境中适合使用结构体： 几何形状的大小，封装一个width属性和height属性，两者均为Double类型。 一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。 三维坐标系内一点，封装x，y和z属性，三者均为Double类型。 在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。 字符串、数组、和字典类型的赋值与复制行为Swift中，所以基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。 Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。 注意以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。 参考： 苹果 swift - Structures and Classes 中文翻译类与结构体]]></content>
      <categories>
        <category>Swift</category>
        <category>Class</category>
        <category>Struct</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS推送系列之Push的工作原理]]></title>
    <url>%2F2018%2F10%2F17%2FPrincipleOfPush%2F</url>
    <content type="text"><![CDATA[Push的工作原理 要理解Push的工作原理，我们必须要知道几个知识点。 设备是如何和APNs保持连接的。 APNs如何识别需要推送的设备。 &emsp;&emsp;APNs可以推送给设备Push消息，是因为设备(iPhone、iPad)和APNs有一个长连接的通道。&emsp;&emsp;iOS的Push通道是一个独立的长连接通道，并且是唯一的一个通道，由iOS系统独立维护。也就是说每一个手机系统，每次开机后，手机后台就会发出一个长连接，连接到苹果服务器(APNs)。当APNs收到新的Push通知的时候就会把通知推送给应用设备。 通过官方的原理图四个身份 Provider：我们的服务器sever APNs：苹果服务器 Device(设备)：iPhone、iPad Client App：客户端的app Tip：苹果可以省电省流量，原因之一有Push网络通道是唯一的一个，并且苹果公司来维护。 总结下大致流程 设备打开某个App后，会生成唯一的一个token，并把这个token上传给我们自己的服务器，我们的服务器有了token，就可以向我们的app推送通知了，这个是前提。但是这个通知并不能直接推送给我们的设备，而是要推送给苹果的服务器。 我们的服务器会将token和推送的内容，一起推送给苹果的服务器。 苹果服务器会根据token定位到设备,将push推送给设备。 设备拿到这个push，就会知道是哪个app。然后就可以将这个通知推送到具体的app。 参考资料 push工作原理 苹果官方push内容 iOS远程推送原理及实现过程]]></content>
      <categories>
        <category>iOS</category>
        <category>push</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>push</tag>
      </tags>
  </entry>
</search>
