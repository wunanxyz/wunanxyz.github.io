<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吴楠的小栈</title>
  
  <subtitle>study hard , study smart</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wunan520.cn/"/>
  <updated>2018-10-29T02:21:09.634Z</updated>
  <id>http://www.wunan520.cn/</id>
  
  <author>
    <name>EmilyWu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOSBug:The operation couldn’t be completed. (DVTCoreSimulatorAdditionsErrorDomain error 0.)</title>
    <link href="http://www.wunan520.cn/2018/10/29/iOS%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    <id>http://www.wunan520.cn/2018/10/29/iOS模拟器/</id>
    <published>2018-10-29T01:59:40.000Z</published>
    <updated>2018-10-29T02:21:09.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>查看磁盘空间的时候，发现系统磁盘消耗太多空间。而且显示是系统消耗的。然后就大举的删除了很多关了XCode和模拟器本地资源。然后运行XCode。发现模拟器一直调不出来，并且XCode提示这个错误，如下</p><blockquote><p>The operation couldn’t be completed. (DVTCoreSimulatorAdditionsErrorDomain error 0.)</p></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwoujzh8gdj30na071t9e.jpg" alt="XCode提示的错误"></p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>重新启动mac</p>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:查看磁盘空间的时候，发现系统磁盘消耗太多空间。而且显示是系统消耗的。然后就大举的删除了很多关了XCode和模拟器本地资源。然后运行XCode。发现模拟器一直调不出来，并且XCode提示这个错误，The operation couldn’t be completed. (DVTCoreSimulatorAdditionsErrorDomain error 0.)
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="bug" scheme="http://www.wunan520.cn/categories/iOS/bug/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="bug" scheme="http://www.wunan520.cn/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Swift4异常处理Try_Catch的使用之初见</title>
    <link href="http://www.wunan520.cn/2018/10/26/Swift4%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86Try-Catch%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%88%9D%E8%A7%81/"/>
    <id>http://www.wunan520.cn/2018/10/26/Swift4异常处理Try-Catch的使用之初见/</id>
    <published>2018-10-26T03:00:05.000Z</published>
    <updated>2018-10-26T03:07:38.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从OC转Swift了。虽然Swift的官方语法的资料看了2遍了。还是在使用的时候遇到点问题。<br>好记性，不如烂笔头。本篇不是高深的内容。只是作为初使用的记录。</p><p>当想给一个函数使用try-catch。需要在函数后加个<code>throws</code>。具体使用，如下<br>先有个错误的枚举<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ErrorType</span>:<span class="title">Error</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ErrorTypeNil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ErrorType1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里需要函数出错会抛出错误的情况，记住后面要加<code>throws</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largerThanEighteenthFunc</span><span class="params">(a:Int16?)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> need = a ,need &gt;= <span class="number">18</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"need &gt;&gt;&gt;&gt; <span class="subst">\(need)</span>"</span>)</span><br><span class="line">        <span class="keyword">throw</span>  <span class="type">ErrorType</span>.<span class="type">ErrorTypeNil</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"need &lt;=18"</span>)</span><br><span class="line">        <span class="keyword">throw</span>  <span class="type">ErrorType</span>.<span class="type">ErrorType1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要捕抓错误，可以使用try!或try?。但是不建议不建议使用try!，使用try?会更加安全。因为如果当有错误捕抓到时，程序会直接崩溃<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notPrintError</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span>? largerThanEighteenthFunc(a: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如果只包含一个catch语句，那么所有的错误都会在这个catch中执行，能够捕抓其错误信息</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">oneCondition</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> largerThanEighteenthFunc(a: <span class="number">9</span>)</span><br><span class="line">       &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">"error &gt;&gt;&gt; <span class="subst">\(error)</span>"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在使用catch时，我们想它是能够进行模式匹配的、能够进行更精准的错误匹配处理。可以穷举多种情况。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoCondition</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> largerThanEighteenthFunc(a: <span class="number">20</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="type">ErrorType</span>.<span class="type">ErrorTypeNil</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">ErrorType</span>.<span class="type">ErrorTypeNil</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="type">ErrorType</span>.<span class="type">ErrorType1</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">ErrorType</span>.<span class="type">ErrorType1</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123; <span class="comment">// 加入一个空的catch，用于关闭catch。否则会报错：Errors thrown from here are not handled because the enclosing catch is not exhaustive</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：在使用do-catch的时候。无论是不是把错误都<strong>穷举</strong>完，一定要写个空catch，不然会报错。<br>这个错误就是</p><blockquote><p><strong>Errors thrown from here are not handled because the enclosing catch is not exhaustive</strong></p></blockquote><p>友情连接：</p><ul><li><a href="https://github.com/wunanxyz/SwiftErrorHandle" target="_blank" rel="noopener">本文代码的github地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
当Swift语言下，想扑捉错误，要使用try-catch。但是具体如何使用，在Swift中和OC还有有不同的。
&lt;/p&gt;

    
    </summary>
    
      <category term="Swift" scheme="http://www.wunan520.cn/categories/Swift/"/>
    
      <category term="try_catch" scheme="http://www.wunan520.cn/categories/Swift/try-catch/"/>
    
    
      <category term="Swift - try_catch" scheme="http://www.wunan520.cn/tags/Swift-try-catch/"/>
    
  </entry>
  
  <entry>
    <title>Swift代理协议的安全使用</title>
    <link href="http://www.wunan520.cn/2018/10/25/Swift%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.wunan520.cn/2018/10/25/Swift代理协议的安全使用/</id>
    <published>2018-10-25T02:59:24.000Z</published>
    <updated>2018-10-25T03:14:58.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>Swift代理协议的安全使用</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwk840t3k2j30vi0frglr.jpg" alt=""></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Swift下，使用代理协议，并且检验代理对象的存在和协议函数是否被实现。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>可空链式调用（Optional Chaining）是一种可以请求和调用属性、方法及下标的过程，它的可空性体现于请求或调用的目标当前可能为空（nil）。如果可空的目标有值，那么调用就会成功；如果选择的目标为空（nil），那么这种调用将返回空（nil）。多个连续的调用可以被链接在一起形成一个调用链，如果其中任何一个节点为空（nil）将导致整个链调用失败。</p><blockquote><p>注意： Swift 的可空链式调用和 Objective-C 中的消息为空有些相像，但是 Swift 可以使用在任意类型中，并且能够检查调用是否成功。</p></blockquote><h2 id="空链式（Optional-Chaining）的使用之一"><a href="#空链式（Optional-Chaining）的使用之一" class="headerlink" title="空链式（Optional Chaining）的使用之一"></a>空链式（Optional Chaining）的使用之一</h2><p>在Swift中空链式的有个实用例子，就是编写代理的时候。当触发协议方法的时候，因为OC是消息型语言，所以必须要判断这个实例是否存在并且要判断当前方法是否被实现，不然没有实现的话，Runtime期间，就可能会报错。又因为OC几乎所以的类都是继承基类NSObject，而根类<code>NSObject</code>实现了其协议<code>NSObject</code>的协议方法<code>respondsToSelector:</code>,该方法可以判断某个方法实现的。如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 判断添加了代理对象，并且该对象实现了某个协议方法</span><br><span class="line">if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(protocalMethod)]) &#123;</span><br><span class="line">    [self.delegate protocalMethod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在Swift语言中，并未要求继承某个根类。并且也未提供某个方法去不判断某个方法是否被实现。其实因为Swift的语言一个特性–可选性，就很好解决这些问题了。正如上方的描述，如果其中任何一个节点为空（nil）将导致整个链调用失败。如下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.delegate?.<span class="type">SwiftProtocolTest</span>?()</span><br></pre></td></tr></table></figure></p><p>当判读使用有代理对象的时候，只需在属性<code>delegate</code>添加”?”就行，而需要判断某个函数是否实现只需在函数名和()之间添加”?”就行。</p><p>提示：本文delegate在Swift和OC的对比可以查看 <a href="https://github.com/wunanxyz/SwiftDelegateUsage.git" target="_blank" rel="noopener">github 代码</a></p><p>友情提示：</p><ul><li><a href="https://developer.apple.com/documentation/swift/optional" target="_blank" rel="noopener">Apple-optional文档</a></li><li><a href="https://developer.apple.com/documentation/swift/cocoa_design_patterns/using_delegates_to_customize_object_behavior" target="_blank" rel="noopener">using_delegates_to_customize_object_behavior</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述: 在Swift下，使用代理协议，并且检验代理对象的存在和协议函数是否被实现。
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.wunan520.cn/categories/iOS/Swift/"/>
    
      <category term="delegate" scheme="http://www.wunan520.cn/categories/iOS/Swift/delegate/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.wunan520.cn/tags/Swift/"/>
    
      <category term="delegate" scheme="http://www.wunan520.cn/tags/delegate/"/>
    
  </entry>
  
  <entry>
    <title>开发环境下PP文件的创建</title>
    <link href="http://www.wunan520.cn/2018/10/23/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8BPP%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>http://www.wunan520.cn/2018/10/23/开发环境下PP文件的创建/</id>
    <published>2018-10-23T09:26:07.000Z</published>
    <updated>2018-10-25T03:14:59.960Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a03441753c443?w=396&amp;h=215&amp;f=jpeg&amp;s=5234" alt=""></p><p>开发环境下Provisioning Profile文件的创建。<br>当我们在做iOS开发的时候,总是添加很多证书，来保证安全性。Provisioning Profile我们又称PP文件。这个文件将证书、App Id和设备相关联。本章节就是教大家如何创建开发环境下的PP文件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a034419938f4e?w=240&amp;h=240&amp;f=jpeg&amp;s=7699" alt=""></p><ol><li>通过该<code>Certificates,Identifiers&amp;Profiles</code>–&gt; <code>Provisioning Profiles</code>–&gt; <code>Development</code>路径，找到Profile文件的列表页面。添加<code>+</code>准备添加新的PP文件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a034419af214f?w=1560&amp;h=1410&amp;f=jpeg&amp;s=160699" alt=""></li></ol><p>2.选择证书的类型，这里选择开发证书。<br><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a03441995e24f?w=1572&amp;h=774&amp;f=jpeg&amp;s=163514" alt=""></p><p>3.选择APPID&amp;证书&amp;设备。</p><p>  3.1 选择对应的 <code>APP ID</code><br>  <img src="https://user-gold-cdn.xitu.io/2018/10/23/166a03442313878b?w=1576&amp;h=860&amp;f=jpeg&amp;s=193482" alt=""></p><p>  3.2 选择对应的证书<br>  <img src="https://user-gold-cdn.xitu.io/2018/10/23/166a034424596e55?w=1572&amp;h=1040&amp;f=jpeg&amp;s=172776" alt=""></p><p>  3.3 选择可以安装软件的设备号，设备号也就是每个硬件设备的序列号。<br><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a0344b02f0e54?w=1578&amp;h=1434&amp;f=jpeg&amp;s=202475" alt=""></p><ol start="4"><li>填写这个PP文件的名称。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a0344b03ead74?w=1576&amp;h=844&amp;f=jpeg&amp;s=168356" alt=""></p><ol start="5"><li>走到这步，说明已经安装成功。点击按钮<code>Download</code>就可以下载了。</li></ol><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwi9kmpldyj317y0r4tdd.jpg" alt=""></p><p>over，是不是很简单。正式环境的PP文件，也是大同小异。有时间也出篇教程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:开发环境下Provisioning Profile文件的创建。
当我们在做iOS开发的时候,总是添加很多证书，来保证安全性。Provisioning Profile我们又称PP文件。这个文件将证书、App Id和设备相关联。本章节就是教大家如何创建开发环境下的PP文件。
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="PP文件" scheme="http://www.wunan520.cn/categories/iOS/PP%E6%96%87%E4%BB%B6/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="PP文件" scheme="http://www.wunan520.cn/tags/PP%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发实用软件之NWPusher</title>
    <link href="http://www.wunan520.cn/2018/10/23/iOS%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%B9%8BNWPusher/"/>
    <id>http://www.wunan520.cn/2018/10/23/iOS开发实用软件之NWPusher/</id>
    <published>2018-10-23T06:08:39.000Z</published>
    <updated>2018-10-23T07:55:00.899Z</updated>
    
    <content type="html"><![CDATA[<p>一个App获取到一个Push内容。必须是服务器拿着对应token和需要的消息内容发给苹果服务器，然后由苹果服务器推送给用户。作为前端开发人员，为了学习Push，去搭建一个服务器，还是很耗时的。想了解<a href="https://www.wunan520.cn/2018/10/17/PrincipleOfPush/">iOS推送系列之Push的工作原理</a>，可以查看这篇博客。</p><p>现在有个软件NWPusher可以模拟服务器发送Push。为我们研究Push提供了便利，我们一起来了解下。</p><h4 id="一、软件的安装"><a href="#一、软件的安装" class="headerlink" title="一、软件的安装"></a>一、软件的安装</h4><p>多种方式：</p><ol><li><p>使用<a href="https://github.com/Homebrew/homebrew-cask" target="_blank" rel="noopener">Homebrew cask</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install pusher</span><br></pre></td></tr></table></figure><ol start="2"><li><p>直接安装Pusher.app</p><p>可以下载软件：<a href="https://github.com/noodlewerk/NWPusher/releases/latest" target="_blank" rel="noopener">最新的下载地址</a></p></li></ol></li><li><p>NWPusher可以可以当做<code>framework</code>使用。<br>这个也有2种方式。</p><p>3.1 使用<code>CocoaPods</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;NWPusher&apos;, &apos;~&gt; 0.7.0&apos;</span><br></pre></td></tr></table></figure><p>3.2 使用<code>Carthage</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github &quot;noodlewerk/NWPusher&quot;</span><br></pre></td></tr></table></figure><h4 id="二、软件的介绍"><a href="#二、软件的介绍" class="headerlink" title="二、软件的介绍"></a>二、软件的介绍</h4><p>软件界面如图：<br><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669f86250c2e9a2?w=1224&amp;h=668&amp;f=jpeg&amp;s=185349" alt=""><br>如图所示：</p><ul><li>我们需要选择<strong>相应的Push开发测试证书</strong>，如果创建证书，可以查看<a href="https://www.wunan520.cn/2018/10/22/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83Push%E8%AF%81%E4%B9%A6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%9B%BE%E6%96%87%E6%B5%81%E7%A8%8B/">开发环境Push证书的创建图文流程</a>这篇博客了解相应的知识。</li><li>添加相应的deviceToken</li><li>选择过期时间:有8种选择。<ul><li>Expiry:None : 不会过期</li><li>immediate(0) :立即</li><li>1 minute :1分钟时</li><li>5 minutes :5分钟时</li><li>1 hour :1小时时</li><li>1 day :1天时</li><li>Far past(1) :遥远的过去</li><li>Far future: :永远</li></ul></li><li>选择优先级：3个<ul><li>Pirority:None :没有优先级</li><li>Conserve power(5) : 电量优先</li><li>immediately(10) : 立刻，其优先级最高</li></ul></li><li>Payload输入内容就是我们需要传送的数据了：这个数据传输以JSON的格式存储。是必要按照APNs发送的Push格式的。Push消息常用的key如下：<ul><li><strong>aps</strong>,是其value是我们需要传送的内容。</li><li><strong>alert</strong>,是其value就是弹出框需要展示的内容。</li><li><strong>badge</strong>,是其value就是APP icon，展示的信息个数。</li><li><strong>sound</strong>,是其value就是表示当有Push消息的时候，是否需要声音提示。</li></ul></li></ul></li></ol><p>另外，alert中value值，可以是字符串，可以是字典。这个字典可以使用多对值，比如其key是<code>title</code>,<code>subtitle</code>,<code>body</code>等。其格式如下<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"aps"</span>: &#123;</span><br><span class="line"><span class="attr">"alert"</span>: &#123;</span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"title"</span>,</span><br><span class="line"><span class="attr">"subtitle"</span>: <span class="string">"subTitle"</span>,</span><br><span class="line"><span class="attr">"body"</span>: <span class="string">"body"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"badge"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"sound"</span>: <span class="string">"default"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更多关于<code>aps</code>,<code>alert</code>,<code>sound</code>等可以查看官网：<a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification?language=objc" target="_blank" rel="noopener">Generating a Remote Notification</a></p><p>所以都填选好，点击按钮 Push。就可以发送了。其发送状态，边上都有发布状态的提示信息。</p><p>友情链接：</p><ul><li><a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification?language=objc" target="_blank" rel="noopener">Generating a Remote Notification</a></li><li><a href="https://github.com/noodlewerk/NWPusher" target="_blank" rel="noopener">NWPusher github地址</a></li><li><a href="https://www.imooc.com/video/15121" target="_blank" rel="noopener">搭建Push环境</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:软件NWPusher可以模拟服务器发送Push。为我们研究Push提供了便利，我们一起来了解下。
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="push" scheme="http://www.wunan520.cn/categories/iOS/push/"/>
    
    
      <category term="push" scheme="http://www.wunan520.cn/tags/push/"/>
    
      <category term="模拟" scheme="http://www.wunan520.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>开发环境Push证书的创建图文流程</title>
    <link href="http://www.wunan520.cn/2018/10/22/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83Push%E8%AF%81%E4%B9%A6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%9B%BE%E6%96%87%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.wunan520.cn/2018/10/22/开发环境Push证书的创建图文流程/</id>
    <published>2018-10-22T07:45:44.000Z</published>
    <updated>2018-10-22T08:25:02.965Z</updated>
    
    <content type="html"><![CDATA[<p>当写Push的时候，必须有相应的证书。而证书的创建也是个知识点。今天以图文的形式写个相关的证书创建的流程。<br>生成对应的APP ID 和证书</p><h4 id="一-添加App-ID"><a href="#一-添加App-ID" class="headerlink" title="一.添加App ID"></a>一.添加App ID</h4><h5 id="1-进入苹果开发中心的App-Id"><a href="#1-进入苹果开发中心的App-Id" class="headerlink" title="1.进入苹果开发中心的App Id"></a>1.进入苹果开发中心的App Id</h5><ol><li>选择 <code>Cerfificates,Identifiers&amp;Profiles</code> –&gt; <code>Identifiers</code> –&gt; <code>App IDs</code></li><li>点击右上角的<code>+</code>来添加证书。<div align="center"><br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwgugjdwesj31i812ajxr.jpg" width="500" hegiht="343" align="center"><br></div></li></ol><h5 id="2-注册一个App-ID"><a href="#2-注册一个App-ID" class="headerlink" title="2.注册一个App ID"></a>2.注册一个<code>App ID</code></h5><p> 在这个页面填写和选择相应的</p><ol><li><p>在<code>App ID Description</code> –&gt; <code>name</code> 输入相应的App Name</p><div align="center"><br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwgvy133lhj31iu11ywmg.jpg" width="500" hegiht="343" align="center"><br></div></li><li><p>在<code>App ID Suffix</code> –&gt; <code>Explicit App ID</code> –&gt; <code>Bundle ID</code> 输入相应的<code>bundle id</code></p><div align="center"><br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwgwdc07xsj31iq12e109.jpg" width="500" hegiht="343" align="center"><br></div></li><li><p>在 App Services –&gt; <code>Enable Services</code> 选择相应的服务。这里选项 <code>Push Notifications</code>。点击<code>continue</code>生成对应的app id</p><div align="center"><br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwgwdy5bcij30yg13wwjg.jpg" width="500" hegiht="343" align="center"><br></div></li></ol><h5 id="3-确认App-Id，这个页面不需要填选任何内容。检查下即将创建的App-ID的内容，是否正确。"><a href="#3-确认App-Id，这个页面不需要填选任何内容。检查下即将创建的App-ID的内容，是否正确。" class="headerlink" title="3. 确认App Id，这个页面不需要填选任何内容。检查下即将创建的App ID的内容，是否正确。"></a>3. 确认<code>App Id</code>，这个页面不需要填选任何内容。检查下即将创建的App ID的内容，是否正确。</h5><div align="center"><br> <img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwgughjyfcj315214u45t.jpg" width="500" hegiht="343" align="center"><br></div> <div align="center"><br>  <img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwguggyr7pj314y0js76k.jpg" width="500" hegiht="343" align="center"><br> </div><p>点击<code>Rigister</code>注册。</p><h5 id="4-完成操作"><a href="#4-完成操作" class="headerlink" title="4. 完成操作"></a>4. 完成操作</h5><p>点击<code>Done</code>完成操作。这个时候<code>App ID</code>就创建成功了。</p><div align="center"><br> <img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwguggjrjtj31e612eahy.jpg" width="500" hegiht="343" align="center"><br></div><br><div align="center"><br> <img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwgugfxc66j31cs0xwgpj.jpg" width="500" hegiht="343" align="center"><br></div><p>生成APP ID 之后，再生成对应的证书，用于身份认证。</p><h3 id="二-进入苹果开发中心的证书"><a href="#二-进入苹果开发中心的证书" class="headerlink" title="二. 进入苹果开发中心的证书"></a>二. 进入苹果开发中心的证书</h3><h5 id="1-进入开发环境证书列表页"><a href="#1-进入开发环境证书列表页" class="headerlink" title="1. 进入开发环境证书列表页"></a>1. 进入开发环境证书列表页</h5><ol><li>选择 <code>Cerfificates,Identifiers&amp;Profiles</code> –&gt; <code>Cerfificates</code> –&gt; <code>Development</code></li><li>点击右上角的<code>+</code>来添加证书。<div align="center"><br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwgugfj4q2j31d80rqwih.jpg" width="500" hegiht="343" align="center"><br></div></li></ol><h6 id="2-选择证书类型"><a href="#2-选择证书类型" class="headerlink" title="2. 选择证书类型"></a>2. 选择证书类型</h6><p>2.1. 因为是需要添加推送证书，选择的证书了类型<code>Apple Push Notification server SSL(SandBox)</code>。然后下一步</p><div align="center"><br> <img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwgugf3lvuj31d20yeqaf.jpg" width="500" hegiht="343" align="center"><br></div><br>2.2. 选择添加<code>App Id</code><br><div align="center"><br> <img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwgx3k81epj31840o40y2.jpg" width="500" hegiht="343" align="center"><br></div><h6 id="3-提交点子信息证书的请求"><a href="#3-提交点子信息证书的请求" class="headerlink" title="3. 提交点子信息证书的请求"></a>3. 提交点子信息证书的请求</h6><p>相应证书创建电子信息证书步骤是提示,点击<code>continue</code>.</p><div align="center"><br> <img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwgugejkp1j318k0y0jyu.jpg" width="500" hegiht="343" align="center"><br></div><h6 id="4-生成"><a href="#4-生成" class="headerlink" title="4. 生成"></a>4. 生成</h6><p>选择添加本地请求文件。如何创建请求文件，从下面的第三部分：创建电子信息证书的步骤获取。</p><div align="center"><br> <img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwgx8l33zuj318o0sk0yr.jpg" width="500" hegiht="343" align="center"><br></div><h6 id="5-下载"><a href="#5-下载" class="headerlink" title="5. 下载"></a>5. 下载</h6><p>证书已经生成成功，下载到本地。</p><div align="center"><br> <img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwgxti05fjj31940wydma.jpg" width="500" hegiht="343" align="center"><br></div><h5 id="6-添加到钥匙串"><a href="#6-添加到钥匙串" class="headerlink" title="6. 添加到钥匙串"></a>6. 添加到钥匙串</h5><p>下载的文件<code>aps_development.cer</code>,双击这个文件来安装。安装成功就会跳转到钥匙串的证书部分，表示安装成功。</p><div align="center"><br> <img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwgymmux4oj315g0pwq7q.jpg" width="500" hegiht="343" align="center"><br></div><h4 id="三-电子证书请求文件的创建。"><a href="#三-电子证书请求文件的创建。" class="headerlink" title="三. 电子证书请求文件的创建。"></a>三. 电子证书请求文件的创建。</h4><ol><li><p>在进入钥匙串中</p><div align="center"><br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwgxhqc919j313m0mkq88.jpg" width="500" hegiht="343" align="center"><br></div></li><li><p>创建电子签名请求</p><p>  a. <code>钥匙串访问</code> –&gt; <code>证书助理</code> –&gt; <code>从证书颁发机构请求...</code></p><div align="center"><br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwgxhs0kezj30ty0em4mk.jpg" width="500" hegiht="343" align="center"><br></div><br>b. 填写添加邮件,选择<code>存储到磁盘</code>。点击<code>继续</code>,选择保存到本地的位置，保存到本地。<br><div align="center"><br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwgxht28tuj30ya0oeae9.jpg" width="500" hegiht="343" align="center"><br></div><br>c.本地的电子签名请求<br><div align="center"><br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwgy7ryal1j30je04g74q.jpg" width="500" hegiht="343" align="center"><br></div></li></ol><p>以上就是整个开发环境Push证书的创建过程。</p><p>参考:</p><ul><li><a href="https://www.imooc.com/video/15120" target="_blank" rel="noopener">搭建Push环境上</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
当写Push的时候，必须有相应的证书。而证书的创建也是个知识点。今天以图文的形式写个相关的证书创建的流程。
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="push" scheme="http://www.wunan520.cn/categories/iOS/push/"/>
    
      <category term="证书" scheme="http://www.wunan520.cn/categories/iOS/push/%E8%AF%81%E4%B9%A6/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="push" scheme="http://www.wunan520.cn/tags/push/"/>
    
      <category term="证书" scheme="http://www.wunan520.cn/tags/%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Swift中Class和Struct异同</title>
    <link href="http://www.wunan520.cn/2018/10/17/Swift%E4%B8%ADClass%E5%92%8CStruct%E5%BC%82%E5%90%8C/"/>
    <id>http://www.wunan520.cn/2018/10/17/Swift中Class和Struct异同/</id>
    <published>2018-10-17T09:46:08.000Z</published>
    <updated>2018-10-25T03:18:18.665Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1683361-ebfc93018b2012ba.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Swift 中类和结构体有很多<strong>共同点</strong>。共同处在于：</p><ul><li>定义属性用于存储值</li><li>定义方法用于提供功能</li><li>定义下标操作使得可以通过<strong>下标</strong>语法来访问实例所包含的值</li><li>定义<strong>构造器</strong>用于生成初始化值</li><li>通过<strong>扩展</strong>以增加默认实现的功能</li><li>实现<strong>协议</strong>以提供某种标准功能</li></ul><p>与结构体相比，类还有如下的附加功能：</p><ul><li><strong>继承</strong>允许一个类继承另一个类的特征</li><li>类型转换允许在运行时检查和解释一个类实例的类型</li><li><strong>析构器</strong>允许一个类实例释放任何其所被分配的资源</li><li>引用计数允许对一个类的多次<strong>引用</strong></li></ul><p><strong>Tip:</strong> 类的对象是<strong>引用类型</strong>，而结构体是<strong>值类型</strong>。所以类的赋值是传递引用，结构体则是Copy传值,不是使用引用计数。</p><p>类为支持的额外功能会增加其复杂性。一般,更倾向使用选择结构和枚举,因为他们更容易理解,而类，则当再在合适和必要的时候使用。实际上,这意味着大多数的自定义数据类型定义为结构和枚举就可以了。更详细的比较,<a href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes" target="_blank" rel="noopener">请参阅结构和类之间的选择</a>。<br></p><h3 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h3><p>类和结构体有着类似的定义方式。我们通过关键字<code>class</code>和<code>struct</code>来分别表示类和结构体，并在一对大括号中定义它们的具体内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里定义类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里定义结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>在定义一个新类或者结构体的时候，实际上是定义了一个新的 Swift 类型。因此请使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），以便符合标准 Swift 类型的大写命名风格（如String，Int和Bool）。相反的，请使用lowerCamelCase这种方式为<strong>属性和方法</strong>命名（如framerate和incrementCount），以便和类型名区分。</p></blockquote><p>以下是定义结构体和定义类的示例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolution = <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="类和结构体实例"><a href="#类和结构体实例" class="headerlink" title="类和结构体实例"></a>类和结构体实例</h3><p>生成结构体和类实例的语法非常相似：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someResolution = <span class="type">Resolution</span>()</span><br><span class="line"><span class="keyword">let</span> someVideoMode = <span class="type">VideoMode</span>()</span><br></pre></td></tr></table></figure></p><p>结构体和类都使用<strong>构造器</strong>语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对<strong>空括号</strong>，如Resolution()或VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为<strong>默认值</strong>。</p><h3 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h3><p>通过使用点语法,访问实例的属性.<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someResolution is <span class="subst">\(someResolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "The width of someResolution is 0"</span></span><br></pre></td></tr></table></figure></p><p>可以访问子属性<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is <span class="subst">\(someVideoMode.resolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "The width of someVideoMode is 0"</span></span><br></pre></td></tr></table></figure></p><p>可以使用点语法为变量属性赋值<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">someVideoMode.resolution.width = <span class="number">1280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is now <span class="subst">\(someVideoMode.resolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "The width of someVideoMode is now 1280"</span></span><br></pre></td></tr></table></figure></p><h3 id="结构体类型的成员逐一构造器"><a href="#结构体类型的成员逐一构造器" class="headerlink" title="结构体类型的成员逐一构造器"></a>结构体类型的成员逐一构造器</h3><p>所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vga = <span class="type">Resolution</span>(width:<span class="number">640</span>, height: <span class="number">480</span>)</span><br></pre></td></tr></table></figure></p><p>与结构体不同，类实例<strong>没有默认的成员逐一构造器</strong>。</p><h3 id="结构体和枚举是值类型"><a href="#结构体和枚举是值类型" class="headerlink" title="结构体和枚举是值类型"></a>结构体和枚举是值类型</h3><p><em>值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。</em></p><p>实际上，在Swift中，<strong>所有的基本类型</strong>：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。</p><p>在<code>Swift</code>中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会<strong>被复制</strong>。</p><h3 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h3><p>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。</p><h3 id="恒等运算符"><a href="#恒等运算符" class="headerlink" title="恒等运算符"></a>恒等运算符</h3><p>因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）<br>如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符：</p><ul><li>等价于（===）</li><li>不等价于（!==）</li></ul><p>运用这两个运算符检测两个常量或者变量是否<strong>引用同一个实例</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tenEighty === alsoTenEighty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"tenEighty and alsoTenEighty refer to the same Resolution instance."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印 "tenEighty and alsoTenEighty refer to the same Resolution instance."</span></span><br></pre></td></tr></table></figure><p>请注意，“等价于”（用三个等号表示，===）与“等于”（用两个等号表示，==）的不同：</p><ul><li>“等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。</li><li>“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法。</li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><code>C</code>，<code>C++</code> 或者<code>Objective-C</code>语言使用指针来引用内存中的地址。一个引用某个引用类型实例的 <code>Swift</code> 常量或者变量，与<code>C</code>语言中的指针类似，<strong>但是并不直接指向某个内存地址</strong>，也不要求你使用星号（*）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。</p><h3 id="类和结构体的选择"><a href="#类和结构体的选择" class="headerlink" title="类和结构体的选择"></a>类和结构体的选择</h3><p>结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。</p><p>按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体：</p><ul><li>该数据结构的主要目的是用来封装<strong>少量</strong>相关<strong>简单</strong>数据值。</li><li>有理由预计该数据结构的实例在<strong>被赋值或传递</strong>时，封装的数据将会<strong>被拷贝而不是被引用</strong>。</li><li>该数据结构中储存的值类型属性，也<strong>应该被拷贝</strong>，而不是被引用。</li><li>该数据结构<strong>不需要去继承</strong>另一个既有类型的属性或者行为。</li></ul><p>举例来说，以下情境中适合使用结构体：</p><ul><li>几何形状的大小，封装一个width属性和height属性，两者均为Double类型。</li><li>一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。</li><li>三维坐标系内一点，封装x，y和z属性，三者均为Double类型。</li></ul><p>在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。</p><h3 id="字符串、数组、和字典类型的赋值与复制行为"><a href="#字符串、数组、和字典类型的赋值与复制行为" class="headerlink" title="字符串、数组、和字典类型的赋值与复制行为"></a>字符串、数组、和字典类型的赋值与复制行为</h3><p><code>Swift</code>中，所以基本类型，诸如String，Array和Dictionary类型均以<strong>结构体</strong>的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。</p><p><code>Objective-C</code> 中NSString，NSArray和NSDictionary类型均以<strong>类</strong>的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。</p><blockquote><p><strong>注意</strong><br>以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在<strong>绝对必要时才执行实际的拷贝</strong>。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。</p></blockquote><p>参考：</p><ul><li><a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html" target="_blank" rel="noopener">苹果 swift - Structures and Classes</a></li><li><a href="http://www.runoob.com/manual/gitbook/swift3/source/_book/chapter2/09_Classes_and_Structures.html#comparing_classes_and_structures" target="_blank" rel="noopener">中文翻译类与结构体</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:	Swift语言中Class的定义和Struct的定义。以及二者创建的对象的异同。
&lt;/p&gt;

    
    </summary>
    
      <category term="Swift" scheme="http://www.wunan520.cn/categories/Swift/"/>
    
      <category term="Class" scheme="http://www.wunan520.cn/categories/Swift/Class/"/>
    
      <category term="Struct" scheme="http://www.wunan520.cn/categories/Swift/Struct/"/>
    
    
      <category term="Swift" scheme="http://www.wunan520.cn/tags/Swift/"/>
    
      <category term="Class" scheme="http://www.wunan520.cn/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>iOS推送系列之Push的工作原理</title>
    <link href="http://www.wunan520.cn/2018/10/17/PrincipleOfPush/"/>
    <id>http://www.wunan520.cn/2018/10/17/PrincipleOfPush/</id>
    <published>2018-10-17T03:40:53.000Z</published>
    <updated>2018-10-22T08:08:55.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Push的工作原理"><a href="#Push的工作原理" class="headerlink" title="Push的工作原理"></a>Push的工作原理</h3><p>  要理解Push的工作原理，我们必须要知道几个知识点。</p><ul><li>设备是如何和APNs保持连接的。</li><li>APNs如何识别需要推送的设备。</li></ul><p>&emsp;&emsp;APNs可以推送给设备Push消息，是因为设备(iPhone、iPad)和APNs有一个长连接的通道。<br>&emsp;&emsp;iOS的Push通道是一个独立的长连接通道，并且是唯一的一个通道，由iOS系统独立维护。也就是说每一个手机系统，每次开机后，手机后台就会发出一个长连接，连接到苹果服务器(APNs)。<br>当APNs收到新的Push通知的时候就会把通知推送给应用设备。</p><p><img src="https://upload-images.jianshu.io/upload_images/1683361-b84ca1f2f30f0748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="苹果官方网站的原理图"></p><p>通过官方的原理图四个身份</p><ul><li>Provider：我们的服务器sever</li><li>APNs：苹果服务器</li><li>Device(设备)：iPhone、iPad</li><li>Client App：客户端的app</li></ul><p><strong>Tip</strong>：苹果可以省电省流量，原因之一有<strong>Push网络通道是唯一的一个</strong>，并且苹果公司来维护。</p><p><img src="https://upload-images.jianshu.io/upload_images/1683361-36e756ff58c58570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="push的工作原理"></p><p>总结下大致流程</p><ol><li>设备打开某个App后，会生成唯一的<strong>一个token</strong>，并把这个token上传给我们自己的服务器，我们的服务器有了token，就可以向我们的app推送通知了，这个是前提。但是这个通知并不能直接推送给我们的设备，而是要推送给苹果的服务器。</li><li>我们的服务器会将token和推送的内容，一起推送给苹果的服务器。</li><li>苹果服务器会根据token定位到设备,将push推送给设备。</li><li>设备拿到这个push，就会知道是哪个app。然后就可以将这个通知推送到具体的app。</li></ol><p>参考资料</p><ul><li><a href="https://www.imooc.com/video/15117" target="_blank" rel="noopener">push工作原理</a></li><li><a href="https://developer.apple.com/documentation/usernotifications?language=objc" target="_blank" rel="noopener">苹果官方push内容</a></li><li><a href="http://www.open-open.com/lib/view/open1462951879679.html" target="_blank" rel="noopener">iOS远程推送原理及实现过程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:	iOS的Push的原理。关于设备如何和APNs建立连接。整个推送的步骤等，一网打尽。
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="push" scheme="http://www.wunan520.cn/categories/iOS/push/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="push" scheme="http://www.wunan520.cn/tags/push/"/>
    
  </entry>
  
</feed>
