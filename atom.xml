<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吴楠的小栈</title>
  
  <subtitle>study hard , study smart</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wunan520.cn/"/>
  <updated>2018-11-15T09:45:51.191Z</updated>
  <id>http://www.wunan520.cn/</id>
  
  <author>
    <name>EmilyWu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NSThead的进阶使用和简单探讨</title>
    <link href="http://www.wunan520.cn/2018/11/15/NSThead%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E5%92%8C%E7%AE%80%E5%8D%95%E6%8E%A2%E8%AE%A8/"/>
    <id>http://www.wunan520.cn/2018/11/15/NSThead的进阶使用和简单探讨/</id>
    <published>2018-11-15T09:37:48.000Z</published>
    <updated>2018-11-15T09:45:51.191Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fx8vl3y323j30w20cet9m.jpg" alt=""></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>NSThread类是一个继承NSObjct类的个轻量级的类。但需要管理线程的生命周期、同步、加锁等问题，这会导致一定的性能开销。<br>使用NSThread类可以让某个OC方法在特定的线程中被调用。当需要执行一个冗长的任务，并且不想让这个任务阻塞应用中的其他部分，尤其为了避免不阻塞app的主线程(因为主线程用于处理用户界面展示交互和事件相关的操作),这个时候非常适合使用多线程。线程也可以将一个庞大的工作分为几个较小的工作，从而提高多核计算机的性能。<br>NSThread类支持监听一个线程在运行期情况的语义和NSOperation相似。比如取消一个线程或者决定一个任务执行完后这个线程是否存在。<br>一个NSThread对象就代表一个线程。</p><p>本文将会从这几个方面开始探讨NSThread</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fx8v8zhytyj30oy0awjs9.jpg" alt=""></p><h2 id="方法属性的介绍"><a href="#方法属性的介绍" class="headerlink" title="方法属性的介绍"></a>方法属性的介绍</h2><p>初始化(创建)一个NSThread对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 返回一个初始化的NSThread对象</span><br><span class="line">- (instancetype)init</span><br><span class="line">// 返回一个带有多个参数的初始化的NSThread对象</span><br><span class="line">// selector ：线程执行的方法,最多只能接收一个参数</span><br><span class="line">// target ：selector消息发送的对象</span><br><span class="line">// argument : 传给selector的唯一参数，也可以是nil</span><br><span class="line">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument );</span><br><span class="line">// iOS 10</span><br><span class="line">- (instancetype)initWithBlock:(void (^)(void))block ;</span><br></pre></td></tr></table></figure></p><p>启动一个线程。<br>使用<code>initWithTarget:selector:</code>、<code>initWithBlock:</code>、<code>detachNewThreadSelector:</code>，<code>detachNewThreadWithBlock:</code>创建都是异步线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 开辟一个新的线程，并且使用特殊的选择器Selector作为线程入口,调用完毕后，会马上创建并开启新线程</span><br><span class="line">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;</span><br><span class="line"> // iOS 10</span><br><span class="line">+ (void)detachNewThreadWithBlock:(void (^)(void))block ;</span><br><span class="line">// 启动接受者</span><br><span class="line">- (void)start</span><br><span class="line">// 线程体方法，线程主要入口，start 后执行</span><br><span class="line">// 该方法默认实现了目标(target)和选择器(selector)，用于初始化接受者和调用指定目标(target)的方法。如果子类化NSThread，需要重写这个方法并且用它来实现这个线程主体。如果这样，是不需要调用super方法的。</span><br><span class="line">// 不应该直接调用这个方法。你应该通过调用启动方法开启一个线程。</span><br><span class="line">- (void)main</span><br></pre></td></tr></table></figure><p>停止一个线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 阻塞当前线程，直到特定的时间。</span><br><span class="line">+ (void)sleepUntilDate:(NSDate *)date;</span><br><span class="line">// 让线程处于休眠状态，在给定的时间间隔</span><br><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</span><br><span class="line">// 终止当前线程</span><br><span class="line">+ (void)exit;</span><br><span class="line">// 改变接收者的取消状态，来表示它应该终止</span><br><span class="line">- (void)cancel</span><br></pre></td></tr></table></figure></p><p>决定线程状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 接收者是否存在</span><br><span class="line">@property (readonly, getter=isExecuting) BOOL executing;</span><br><span class="line">// 接收者是否结束执行</span><br><span class="line">@property (readonly, getter=isFinished) BOOL finished;</span><br><span class="line">// 接收者是否取消</span><br><span class="line">@property (readonly, getter=isCancelled) BOOL cancelled;</span><br></pre></td></tr></table></figure></p><p>主线程相关<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 返回Boolean值，表示当前线程是否是主线程</span><br><span class="line">@property (class, readonly) BOOL isMainThread ;</span><br><span class="line">// Boolean值，表示接受者是否是主线程</span><br><span class="line">@property (readonly) BOOL isMainThread ;</span><br><span class="line">// 返回一个表示是主线程的对象</span><br><span class="line">@property (class, readonly, strong) NSThread *mainThread;</span><br></pre></td></tr></table></figure></p><p>执行环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 返回这个app是不是多线程</span><br><span class="line">+ (BOOL)isMultiThreaded;</span><br><span class="line">// 返回当前执行线程的线程对象。</span><br><span class="line">@property (class, readonly, strong) NSThread *currentThread;</span><br><span class="line">// 返回一个数组，包括回调堆栈返回的地址</span><br><span class="line">@property (class, readonly, copy) NSArray&lt;NSNumber *&gt; *callStackReturnAddresses ;</span><br><span class="line">// 返回一个数组，包括回调堆栈信号</span><br><span class="line">@property (class, readonly, copy) NSArray&lt;NSString *&gt; *callStackSymbols;</span><br></pre></td></tr></table></figure></p><p>线程属性相关<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 线程对象的字典</span><br><span class="line">@property (readonly, retain) NSMutableDictionary *threadDictionary;</span><br><span class="line"></span><br><span class="line">NSAssertionHandlerKey</span><br><span class="line">// 接收者的名字</span><br><span class="line">@property (nullable, copy) NSString *name;</span><br><span class="line">// 接收者的对象大小，以byte为单位</span><br><span class="line">@property NSUInteger stackSize;</span><br></pre></td></tr></table></figure></p><p>线程优先级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 线程开启后是个自读属性</span><br><span class="line">@property NSQualityOfService qualityOfService;</span><br><span class="line">// 返回当前线程的优先级</span><br><span class="line">+ (double)threadPriority;</span><br><span class="line">// 接受者的优先级，已经废弃，使用qualityOfService代替</span><br><span class="line">@property double threadPriority;</span><br><span class="line">// 设置当前线程的优先级。设置线程的优先级(0.0 - 1.0，1.0最高级)</span><br><span class="line">+ (BOOL)setThreadPriority:(double)p</span><br></pre></td></tr></table></figure></p><p>通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 未被实现，没有实际意义，保留项</span><br><span class="line">NSDidBecomeSingleThreadedNotification</span><br><span class="line">// 在线程退出前，当一个NSThread对象收到到退出消息时发送这个通知，观察者在退出前，在线程退出中观察者方法被调用去接收这个通知。</span><br><span class="line">NSThreadWillExitNotification</span><br><span class="line">// 当第一个线程从当前线程启动发送通知。NSThread类发送这个通知，最多一次，第一次是一个线程派遣使用`detachNewThreadSelector:toTarget:withObject:`,`start`方法。后续调用这些方法是不会发送通知。这个通知的观察者有他们的通知方法是在主线程中调用而新线程。观察者通知总是被执行，当新的线程开始执行。</span><br><span class="line">NSWillBecomeMultiThreadedNotification</span><br></pre></td></tr></table></figure></p><p>线程间通信，<br>NSObject分类NSThreadPerformAdditions中方法(NSThread.h文件中)<br>1、在主线程和子线程中均可执行，均会调用主线程的aSelector方法；<br>2、方法是异步的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (NSThreadPerformAdditions)</span><br><span class="line">// 如果设置wait为YES: 等待当前线程执行完以后，主线程才会执行aSelector方法；</span><br><span class="line">// 如果设置wait为NO：不等待当前线程执行完，就在主线程上执行aSelector方法。</span><br><span class="line">// 如果，当前线程就是主线程，那么aSelector方法会马上执行，wait是YES参数无效。</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</span><br><span class="line"></span><br><span class="line">// 等于第一个方法中modes是kCFRunLoopCommonModes的情况。指定了线程中 Runloop 的 Modes =  kCFRunLoopCommonModes。</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line"></span><br><span class="line">// 在指定线程上操作，因为子线程默认未添加NSRunloop，在添加runloop时，是不会调用选择器中的方法的。</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait modes:( NSArray&lt;NSString *&gt; *)array ;</span><br><span class="line">// 等于第一个方法中modes是kCFRunLoopCommonModes的情况。</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait ;</span><br><span class="line"></span><br><span class="line">// 隐式创建子线程,在后台创建。并且是个同步线程。</span><br><span class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg ;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h2 id="直接给接受者发消息的其他方法。"><a href="#直接给接受者发消息的其他方法。" class="headerlink" title="直接给接受者发消息的其他方法。"></a>直接给接受者发消息的其他方法。</h2><ol><li>协议NSObject中的方法，可在主线程或者子线程执行,在当前线程执行的同步任务，会阻塞当前线程。等同于直接调用方法。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前线程操作。</span><br><span class="line">- (id)performSelector:(SEL)aSelector;</span><br><span class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object;</span><br><span class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</span><br></pre></td></tr></table></figure><ol start="2"><li>延迟操作&amp;按照顺序操作</li></ol><p>NSRunLoop.h文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 延迟操作</span><br><span class="line">/**************** Delayed perform ******************/</span><br><span class="line"></span><br><span class="line">@interface NSObject (NSDelayedPerforming)</span><br><span class="line">// 异步方法，不会阻塞当前线程，只能在主线程中执行。是把` Selector `加到主队列里，当 `delay `之后执行`Selector`。如果主线程在执行业务，那只能等到执行完所有业务之后才会去执行`Selector`，就算`delay`等于 0。</span><br><span class="line">// 那`delay `从什么时候开始计算呢？从发送`performSelector`消息的时候。就算这时主线程在阻塞也会计算时间，当阻塞结束之后，如果到了`delay`那就执行`Selector`，如果没到就继续 `delay`。</span><br><span class="line">// 只能在主线程中执行，在子线程中不会调到aSelector方法</span><br><span class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;</span><br><span class="line">// 等于第一个方法中modes是kCFRunLoopCommonModes的情况。指定了线程中 Runloop 的 Modes =  kCFRunLoopCommonModes。</span><br><span class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</span><br><span class="line">// 在方法未到执行时间之前，取消方法。调用这2个方法当前target执行dealloc之前，以确保不会Crash。</span><br><span class="line">+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;</span><br><span class="line">+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">// 按照排序顺序执行</span><br><span class="line">@interface NSRunLoop (NSOrderedPerform)</span><br><span class="line">// 按某种顺序order执行方法。参数order越小，优先级越高，执行越早</span><br><span class="line">// selector都是target的方法，argument都是target的参数</span><br><span class="line">// 这2个方法会设置一个定时器去在下个runloop循环的开始时让target执行aSelector消息。 定时器根据modes确认模式。当定时器触发，定时器尝试队列从runloop中拿出消息并执行。</span><br><span class="line">如果run loop 正在运行，并且是指定modes的一种，则是成功的，否则定时器一直等待直到runloop是modes 中的一种。</span><br><span class="line">- (void)performSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg order:(NSUInteger)order modes:(NSArray&lt;NSRunLoopMode&gt; *)modes;</span><br><span class="line">- (void)cancelPerformSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg;</span><br><span class="line">- (void)cancelPerformSelectorsWithTarget:(id)target;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>本文介绍大部分的知识点如思维导图：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fx8vhu5inmj30u011se0d.jpg" alt=""></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>创建线程<br>用initXXX初始化的需要调用start方法来启动线程。而detachXXX初始化方法，直接启动线程。显示调用线程。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//1. 手动开启 action-target 方式</span><br><span class="line">NSThread * actionTargetThread = [[NSThread alloc] initWithTarget:self selector:@selector(add:) object:nil];</span><br><span class="line">[actionTargetThread start];</span><br><span class="line">//2. 手动开启 block 方式</span><br><span class="line">NSThread *blockThread = [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;];</span><br><span class="line">[blockThread start];</span><br><span class="line">//3. 创建就启动 action-target 方式</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(add2:) toTarget:self withObject:@&quot;detachNewThreadSelector&quot;];</span><br><span class="line">//4. 创建就启动 block 方式</span><br><span class="line">[NSThread detachNewThreadWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ol start="2"><li>线程中通信</li></ol><p>2.1 NSThreadPerformAdditions分类方法，异步方法<br>// 无论在子线程还是主线程，都会调用主线程犯法。<br>a. 主线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self performSelectorOnMainThread:@selector(add:) withObject:nil waitUntilDone:YES];</span><br><span class="line">//[self performSelectorOnMainThread:@selector(add:) withObject:@&quot;arg&quot; waitUntilDone:YES modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]];</span><br></pre></td></tr></table></figure><p>子线程默认没有开启runloop。需要手动添加，不然选择器方法无法调用。<br>b. 子线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1. 开辟一个子线程</span><br><span class="line">NSThread *subThread1 = [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line">  // 2.子线程方法中添加runloop</span><br><span class="line">  // 3.实现线程方法</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;];</span><br><span class="line">//1.2. 启动一个子线程</span><br><span class="line">[subThread1 start];</span><br><span class="line">// 2. 在子线程中调用方法</span><br><span class="line">// [self performSelector:@selector(add:) onThread:subThread1 withObject:@&quot;22&quot; waitUntilDone:YES];</span><br><span class="line">[self performSelector:@selector(add:) onThread:subThread1 withObject:@&quot;arg&quot; waitUntilDone:YES modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1. 开辟一个子线程</span><br><span class="line">NSThread *subThread2 = [[NSThread alloc] initWithTarget:self selector:@selector(startThread) object:nil];</span><br><span class="line">// 1.2 启动一个子线程</span><br><span class="line">[subThread2 start];</span><br><span class="line">// 3. 在子线程中调用方法</span><br><span class="line">// [self performSelector:@selector(add:) onThread:subThread2 withObject:@&quot;22&quot; waitUntilDone:YES];</span><br><span class="line">[self performSelector:@selector(add:) onThread:subThread1 withObject:@&quot;arg&quot; waitUntilDone:YES modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]];</span><br><span class="line">// 2.子线程方法中添加runloop</span><br><span class="line">- (void)startThread&#123;</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. 后台线程(隐式创建一个线程)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelectorInBackground:@selector(add:) withObject:@&quot;arg&quot;];</span><br></pre></td></tr></table></figure><p>2.2 协议NSObject方法，同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadWithBlock:^&#123;</span><br><span class="line">    // 直接调用</span><br><span class="line">    [self performSelector:@selector(add:) withObject:@&quot;xxx&quot;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>2.3 延迟<br>NSObject分类NSDelayedPerforming方法，异步操作，并且是在主线程上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(add:) withObject:self afterDelay:2];</span><br></pre></td></tr></table></figure></p><p>2.4 按照顺序操作<br>NSRunLoop分类NSOrderedPerform中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadWithBlock:^&#123;</span><br><span class="line">    NSRunLoop *currentRunloop = [NSRunLoop currentRunLoop];</span><br><span class="line">    // 记得添加端口。不然无法调用selector方法</span><br><span class="line">    [currentRunloop addPort:[NSPort port] forMode:(NSRunLoopMode)kCFRunLoopCommonModes];</span><br><span class="line">    [currentRunloop performSelector:@selector(add:) target:self argument:@&quot;arg1&quot; order:1 modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]];</span><br><span class="line">    [currentRunloop performSelector:@selector(add:) target:self argument:@&quot;arg3&quot; order:3 modes:@[(NSRunLoopMode)kCFRunLoopDefaultMode]];</span><br><span class="line">    [currentRunloop run];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>问题：<br>多个线程可能会访问同一块资源。比如多个线程同时访问同一个对象、同一个变量、同一个文件等。多个线程同时抢夺同一个资源，会引起线程不安全，可能会造成数据错乱和数据安全问题。<br>解决：<br>使用线程同步技术:在可能会被抢夺的资源，在被被竞争的时候加锁。让其保证线程同步状态。锁有多种：读写锁、自旋锁、互斥锁、信号量、条件锁等。互斥锁就是多个顺序的执行。这里用互斥锁的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (NSInteger index = 0 ; index &lt; 100; index ++) &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        self.allCount -= 5;</span><br><span class="line">        NSLog(@&quot;%@卖出了车票，还剩%ld&quot;,[NSThread currentThread].name,self.allCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对需要读写操作的资源，加锁。</p><h2 id="线程生命周期。"><a href="#线程生命周期。" class="headerlink" title="线程生命周期。"></a>线程生命周期。</h2><p>线程的生命周期是：新建 - 就绪 - 运行 - 阻塞 - 死亡。当线程启动后，它不能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fx8tu81vi4j30mu0fr3zr.jpg" alt=""></p><ol><li><p>新建和就绪状态<br>显式创建，使用<code>initWithTarget:selector:</code>和<code>initWithBlock:</code>创建一个线程，未启动，只有发送start消息才会启动，然后处于就行状态。<br>使用<code>detachNewThreadWithBlock:</code>和<code>detachNewThreadSelector:toTarget:</code>显示创建并立即启动。 还有种创建方式，隐式创建并立即启动:<code>performSelectorInBackground:withObject:</code>。</p></li><li><p>运行和阻塞状态<br>如果处于就绪状态的线程获得了CPU资源，开始执行可执行方法的线程执行体(block或者@Selector)，则该线程处于运行状态。</p></li></ol><p>当发生如下情况下，线程将会进入阻塞状态：</p><ul><li>线程调用sleep方法:<code>sleepUntilDate:</code> <code>sleepForTimeInterval:</code>主动放弃所占用的处理器资源。</li><li>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。<br>线程试图获得一个同步监视器，但该同步监视器正被其他线程锁持有。</li><li>线程在等待某个通知(notify)。</li><li>程序调用了线程的suspend方法将该线程挂起。不过这个方法容易导致死锁，所以程序应该尽量避免使用该方法。<br>  当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会了。被阻塞的线程会在合适时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是<br>说被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。<br>针对上面的几种情况，当发生如下特定的情况将可以解除上面的阻塞，让该线程重新进入就绪状态：</li><li>调用sleep方法的线程经过了指定时间。</li><li>线程调用的阻塞式IO方法已经返回。</li><li>线程成功地获得了试图取得同步监视器。</li><li>线程正在等待某个通知时，其他线程发出了一个通知。</li><li>处于挂起状态的线程被调用了resume恢复方法。</li></ul><ol start="3"><li>线程死亡</li></ol><ul><li>可执行方法执行完成，线程正常结束。</li><li>程序的意外奔溃。</li><li>该线程的发送exit消息来结束该线程。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建：New状态</span><br><span class="line">NSThread * actionTargetThread = [[NSThread alloc] initWithTarget:self selector:@selector(add:) object:nil];</span><br><span class="line">// 2. 启动：就绪状态</span><br><span class="line">[actionTargetThread start];</span><br><span class="line">// 可执行方法</span><br><span class="line">- (void)add:(id)info&#123;</span><br><span class="line">    // 3. 执行状态</span><br><span class="line">    NSLog(@&quot;%s,info %@&quot;,__func__,info);</span><br><span class="line">    // 5. 当前线程休眠</span><br><span class="line">    [NSThread sleepForTimeInterval:1.0];</span><br><span class="line">    NSLog(@&quot;after&quot;);</span><br><span class="line">    // 4. 程序正常退出</span><br><span class="line">&#125;</span><br><span class="line">// 6. 打取消标签</span><br><span class="line">[actionTargetThread cancel];</span><br><span class="line">// 7. 主动退出</span><br><span class="line">[NSThread exit];</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>NSThread 管理多个线程比较困难,所以不太推荐使用</li><li>苹果建议，现在推荐用GCD和NSOperation</li><li>[NSTread currentThread] 跟踪任务所在线程,适用于NSTread,NSOperation,和GCD</li><li>用NSThread创建的线程,不会自动添加autoreleasepool</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.apple.com/documentation/foundation/nsthread?language=objc" target="_blank" rel="noopener">nsthread apple 文档</a></li><li><a href="https://www.cnblogs.com/keessi/p/7444263.html" target="_blank" rel="noopener">线程的生命周期</a></li><li><a href="https://blog.csdn.net/houbin0912/article/details/77969563" target="_blank" rel="noopener">线程的生命周期及五种基本状态</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot; align=&quot;center&quot;&gt;
概述:NSThread类是一个继承NSObjct类的个轻量级的类。但需要管理线程的生命周期、同步、加锁等问题，这会导致一定的性能开销。使用NSThread类可以让某个OC方法在特定的线程中被调用。当需要执行一个冗长的任务，并且不想让这个任务阻塞应用中的其他部分，尤其为了避免不阻塞app的主线程(因为主线程用于处理用户界面展示交互和事件相关的操作),这个时候非常适合使用多线程。线程也可以将一个庞大的工作分为几个较小的工作，从而提高多核计算机的性能。NSThread类支持监听一个线程在运行期情况的语义和NSOperation相似。比如取消一个线程或者决定一个任务执行完后这个线程是否存在。一个NSThread对象就代表一个线程。
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="OC" scheme="http://www.wunan520.cn/categories/iOS/OC/"/>
    
      <category term="NSThread" scheme="http://www.wunan520.cn/categories/iOS/OC/NSThread/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="OC" scheme="http://www.wunan520.cn/tags/OC/"/>
    
      <category term="NSThread" scheme="http://www.wunan520.cn/tags/NSThread/"/>
    
  </entry>
  
  <entry>
    <title>iOS缓存策略之NSCache的简单使用</title>
    <link href="http://www.wunan520.cn/2018/11/15/iOS%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E4%B9%8BNSCache%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.wunan520.cn/2018/11/15/iOS缓存策略之NSCache的简单使用/</id>
    <published>2018-11-14T16:27:36.000Z</published>
    <updated>2018-11-14T16:30:33.543Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fx7q4jrh93j310a0f6myq.jpg" alt=""></p><p>NSCache是一个继承NSObjec的可变集合，是苹果提供的一套缓存机制，用键值(key-value)对来临时存储只需要短暂存储在内存中的数据，并且当内存空间很少的时候会可以自动释放一些资源。</p><h2 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h2><p>缓存(cache)对象和其他可变集合不同的几个方面。</p><ul><li><code>NSCache</code>类包含了各种自动销毁策略，来保证缓存内容没有占用过多的系统内存。如果其他应用需要内存，这些策略会从系统中移除一些选项内容，来减少当前app占用的内存空间。</li><li>可以在不同的线程中对内存中的缓存执行添加、移除和查询操作，而不必自己锁住缓存,因为是线程安全的。</li><li>不同于<code>NSMutableDictionary</code>对象，缓存使用的key是不需要是实现NSCopying协议的，NSMutableDictionary是非线程安全的，在OC中可变类型一般都是非线程安全的。</li><li><code>NSCache</code>可以指定缓存数量(限额)和一共可用的空间容量，当缓存超出限额或者可用内存容量会自动释放相应内存。</li></ul><p>通常使用NSCache对象去临时存储那些创建很昂贵的过渡数据。重用这些数据可以提供性能优势，因为这些值没必要被重新计算。有些数据并非是关键数据，在内存紧张的时候，可以被丢弃。如果丢弃，这些值将会被重新计算。</p><p>具有子组件的对象在没有被使用时可以被丢弃，该对象可以采用NSDiscardableContent协议，去提高缓存回收行为。默认情况下。在缓存中的NSDiscardableContent对象丢弃的内容会被自动移出缓存，即使这个自动移除政策是可以修改的。如果一个NSDiscardableContent对象被放进缓存中，那么当该对象被移出时会调用discardContentIfPossible。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>以下可以使用，从多个方法介绍NSCache。<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fx81dnta7vj314k0j4jta.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 缓存的名称</span><br><span class="line">@property (copy) NSString *name;</span><br></pre></td></tr></table></figure><p>设置缓存空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 对象缓存可持有最大的数量 ，默认是0 没有限制），一旦超出限额，会自动删除之前添加的缓存数据</span><br><span class="line">@property NSUInteger countLimit;</span><br><span class="line">// 缓存中可持有的最大空间 默认是0（没有限制）</span><br><span class="line">@property NSUInteger totalCostLimit;</span><br></pre></td></tr></table></figure></p><p>管理丢弃内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 是否可以自动缓存清除可丢弃的内容，默认是YES</span><br><span class="line">@property BOOL evictsObjectsWithDiscardedContent;</span><br><span class="line">// 可以实现这个协议，当类的对象有可以被销毁不再使用的子组件。这样使用app占用更少的内存空间。</span><br><span class="line">NSDiscardableContent</span><br></pre></td></tr></table></figure></p><p>设置代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// cache的代理</span><br><span class="line">@property (nullable, assign) id&lt;NSCacheDelegate&gt; delegate;</span><br><span class="line">// 一个NSCache对象的代理，实现这些协议代理，去将对象从缓存中移除</span><br><span class="line">NSCacheDelegate</span><br></pre></td></tr></table></figure></p><p>获取一个缓存值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 返回给定key关联的value值</span><br><span class="line">- (nullable ObjectType)objectForKey:(KeyType)key;</span><br></pre></td></tr></table></figure><p>添加和移除缓存值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 根据key值设置在缓存中的value值</span><br><span class="line">- (void)setObject:(ObjectType)obj forKey:(KeyType)key; // 0 cost</span><br><span class="line">// 根据key值设置在缓存中的value值，并且指定关联key-value对的成本</span><br><span class="line">- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;</span><br><span class="line">// 根据key值移除在缓存的value值</span><br><span class="line">- (void)removeObjectForKey:(KeyType)key;</span><br><span class="line">// 清空全部缓存，调用次方法依然可以添加新值，网上很多复制粘贴的博客，都说调用次方法后不能添加，亲测是可以的。</span><br><span class="line">- (void)removeAllObjects;</span><br></pre></td></tr></table></figure><p>NSCacheDelegate 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSCacheDelegate &lt;NSObject&gt;</span><br><span class="line">@optional</span><br><span class="line">// 回收内存空间使用。</span><br><span class="line">// cache 缓存对象。</span><br><span class="line">// obj 被回收的对象。</span><br><span class="line">- (void)cache:(NSCache *)cache willEvictObject:(id)obj;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>在NSObject.h中的可以废弃内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/***********Discardable Content***********/</span><br><span class="line"></span><br><span class="line">@protocol NSDiscardableContent</span><br><span class="line">@required</span><br><span class="line">- (BOOL)beginContentAccess;</span><br><span class="line">- (void)endContentAccess;</span><br><span class="line">- (void)discardContentIfPossible;</span><br><span class="line">- (BOOL)isContentDiscarded;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface NSObject (NSDiscardableContentProxy)</span><br><span class="line">@property (readonly, retain) id autoContentAccessingProxy;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ol><li><p>初始化对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1. 初始化数据</span><br><span class="line">- (NSCache *)mainCache&#123;</span><br><span class="line">    if (!_mainCache) &#123;</span><br><span class="line">        _mainCache = [[NSCache alloc] init];</span><br><span class="line">        _mainCache.countLimit = 300; // 限制个数，默认是0，无限空间</span><br><span class="line">        _mainCache.totalCostLimit = 5*1024*1024; // 设置大小设置，默认是0，无限空间</span><br><span class="line">        _mainCache.name = @&quot;cache1&quot;;</span><br><span class="line">        _mainCache.delegate = self;</span><br><span class="line">    &#125;</span><br><span class="line">    return _mainCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 添加缓存</span><br><span class="line"> [self.mainCache setObject:data forKey:str];</span><br></pre></td></tr></table></figure></li><li><p>移除。在内存警告的时候（<code>didReceiveMemoryWarning</code>）移除缓存。给对象发送<code>removeAllObjects</code>，后添加缓存<code>setObject:forKey:</code>是可以的，可以再添加进去的。还有一个根据key移除对应的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self.mainCache removeAllObjects];</span><br><span class="line">//[self.mainCache removeObjectForKey:@&quot;XXX&quot;];</span><br></pre></td></tr></table></figure></li><li><p>代理<br>在当前对象遵守NSCacheDelegate协议。并且实现协议。并且让当前对象成为代理<code>_mainCache.delegate = self;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)cache:(NSCache *)cache willEvictObject:(id)obj&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><ul><li><a href="https://developer.apple.com/documentation/foundation/nscache?language=objc" target="_blank" rel="noopener">Apple NSCache 文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:NSCache是一个继承NSObjec的可变集合，是苹果提供的一套缓存机制，用键值(key-value)对来临时存储只需要短暂存储在内存中的数据，并且当内存空间很少的时候会可以自动释放一些资源。

&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="OC" scheme="http://www.wunan520.cn/categories/iOS/OC/"/>
    
      <category term="NSCache" scheme="http://www.wunan520.cn/categories/iOS/OC/NSCache/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="OC" scheme="http://www.wunan520.cn/tags/OC/"/>
    
      <category term="NSCache" scheme="http://www.wunan520.cn/tags/NSCache/"/>
    
  </entry>
  
  <entry>
    <title>知识点：id和NSObject *对比，以及id &lt;NSObject&gt;介绍</title>
    <link href="http://www.wunan520.cn/2018/11/06/id-NSObject/"/>
    <id>http://www.wunan520.cn/2018/11/06/id-NSObject/</id>
    <published>2018-11-06T05:38:25.000Z</published>
    <updated>2018-11-06T05:43:03.058Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1683361-1fdaa748420739f0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>在obj.h的类文件中，可以看出id类型和NSObject类型的信息。如下：</p><p><strong>类 id</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type(隐含类型) that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa ;</span><br><span class="line">&#125;;</span><br><span class="line">/// A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure></p><p><strong>类 NSObject</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>协议 NSObject</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSObject</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p><strong>类 NSProxy</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface NSProxy &lt;NSObject&gt; &#123;</span><br><span class="line">    Classisa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>id和NSObject对比</li></ol><ul><li>从上面的源码可以看出，id是struct objc_object结构体指针,可以指向任何OC对象，当然不包括NSInteger等，因为这些数据类型不是OC对象。另外OC的基类，其实不仅仅就NSObject一个，虽然NSObject是绝大数OC对象的基类，但是还有个NSProxy虚类。<br>所以不能说id类型和<code>NSObject *</code>是等价的。</li><li>id类型的实例在编译阶段不会做类型检测，会在运行时确定，所以id类型是运行时的动态类型。类NSObject的实例会编译期要做编译检查，保证指针指向是其NSObject类或其子类，当然实例的具体类型要在运行期确定，这也是iOS的多态的体现。</li><li>id指针的会有局限性：调用方法,只能使用中括弧，不能使用点语法。</li></ul><ol start="2"><li>id \<nsobject> 是什么呢？<br>这里的<code>NSObject</code>是协议NSObject(protocol)而非类NSObject。所以这里表示是遵守协议NSObject的所以类。另外NSObject类和NSProxy类都是实现了协议NSObject。</nsobject></li></ol><p>不错的推荐：</p><ul><li><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">oc runtime源码</a> 版本 <a href="https://opensource.apple.com/tarballs/objc4/objc4-723.tar.gz" target="_blank" rel="noopener">objc4-723</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:作为万能类型id类型，和大多数OC对象的基类的对比。
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="OC" scheme="http://www.wunan520.cn/categories/iOS/OC/"/>
    
      <category term="id" scheme="http://www.wunan520.cn/categories/iOS/OC/id/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="OC" scheme="http://www.wunan520.cn/tags/OC/"/>
    
      <category term="id" scheme="http://www.wunan520.cn/tags/id/"/>
    
  </entry>
  
  <entry>
    <title>iOSBug:The operation couldn’t be completed. (DVTCoreSimulatorAdditionsErrorDomain error 0.)</title>
    <link href="http://www.wunan520.cn/2018/10/29/iOS%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    <id>http://www.wunan520.cn/2018/10/29/iOS模拟器/</id>
    <published>2018-10-29T01:59:40.000Z</published>
    <updated>2018-10-29T02:21:09.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>查看磁盘空间的时候，发现系统磁盘消耗太多空间。而且显示是系统消耗的。然后就大举的删除了很多关了XCode和模拟器本地资源。然后运行XCode。发现模拟器一直调不出来，并且XCode提示这个错误，如下</p><blockquote><p>The operation couldn’t be completed. (DVTCoreSimulatorAdditionsErrorDomain error 0.)</p></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwoujzh8gdj30na071t9e.jpg" alt="XCode提示的错误"></p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>重新启动mac</p>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:查看磁盘空间的时候，发现系统磁盘消耗太多空间。而且显示是系统消耗的。然后就大举的删除了很多关了XCode和模拟器本地资源。然后运行XCode。发现模拟器一直调不出来，并且XCode提示这个错误，The operation couldn’t be completed. (DVTCoreSimulatorAdditionsErrorDomain error 0.)
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="bug" scheme="http://www.wunan520.cn/categories/iOS/bug/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="bug" scheme="http://www.wunan520.cn/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Swift4异常处理Try_Catch的使用之初见</title>
    <link href="http://www.wunan520.cn/2018/10/26/Swift4%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86Try-Catch%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%88%9D%E8%A7%81/"/>
    <id>http://www.wunan520.cn/2018/10/26/Swift4异常处理Try-Catch的使用之初见/</id>
    <published>2018-10-26T03:00:05.000Z</published>
    <updated>2018-10-26T03:07:38.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从OC转Swift了。虽然Swift的官方语法的资料看了2遍了。还是在使用的时候遇到点问题。<br>好记性，不如烂笔头。本篇不是高深的内容。只是作为初使用的记录。</p><p>当想给一个函数使用try-catch。需要在函数后加个<code>throws</code>。具体使用，如下<br>先有个错误的枚举<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ErrorType</span>:<span class="title">Error</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ErrorTypeNil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ErrorType1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里需要函数出错会抛出错误的情况，记住后面要加<code>throws</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largerThanEighteenthFunc</span><span class="params">(a:Int16?)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> need = a ,need &gt;= <span class="number">18</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"need &gt;&gt;&gt;&gt; <span class="subst">\(need)</span>"</span>)</span><br><span class="line">        <span class="keyword">throw</span>  <span class="type">ErrorType</span>.<span class="type">ErrorTypeNil</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"need &lt;=18"</span>)</span><br><span class="line">        <span class="keyword">throw</span>  <span class="type">ErrorType</span>.<span class="type">ErrorType1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要捕抓错误，可以使用try!或try?。但是不建议不建议使用try!，使用try?会更加安全。因为如果当有错误捕抓到时，程序会直接崩溃<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notPrintError</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span>? largerThanEighteenthFunc(a: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如果只包含一个catch语句，那么所有的错误都会在这个catch中执行，能够捕抓其错误信息</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">oneCondition</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> largerThanEighteenthFunc(a: <span class="number">9</span>)</span><br><span class="line">       &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">"error &gt;&gt;&gt; <span class="subst">\(error)</span>"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在使用catch时，我们想它是能够进行模式匹配的、能够进行更精准的错误匹配处理。可以穷举多种情况。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoCondition</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> largerThanEighteenthFunc(a: <span class="number">20</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="type">ErrorType</span>.<span class="type">ErrorTypeNil</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">ErrorType</span>.<span class="type">ErrorTypeNil</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="type">ErrorType</span>.<span class="type">ErrorType1</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">ErrorType</span>.<span class="type">ErrorType1</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123; <span class="comment">// 加入一个空的catch，用于关闭catch。否则会报错：Errors thrown from here are not handled because the enclosing catch is not exhaustive</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：在使用do-catch的时候。无论是不是把错误都<strong>穷举</strong>完，一定要写个空catch，不然会报错。<br>这个错误就是</p><blockquote><p><strong>Errors thrown from here are not handled because the enclosing catch is not exhaustive</strong></p></blockquote><p>友情连接：</p><ul><li><a href="https://github.com/wunanxyz/SwiftErrorHandle" target="_blank" rel="noopener">本文代码的github地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
当Swift语言下，想扑捉错误，要使用try-catch。但是具体如何使用，在Swift中和OC还有有不同的。
&lt;/p&gt;

    
    </summary>
    
      <category term="Swift" scheme="http://www.wunan520.cn/categories/Swift/"/>
    
      <category term="try_catch" scheme="http://www.wunan520.cn/categories/Swift/try-catch/"/>
    
    
      <category term="Swift - try_catch" scheme="http://www.wunan520.cn/tags/Swift-try-catch/"/>
    
  </entry>
  
  <entry>
    <title>Swift代理协议的安全使用</title>
    <link href="http://www.wunan520.cn/2018/10/25/Swift%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.wunan520.cn/2018/10/25/Swift代理协议的安全使用/</id>
    <published>2018-10-25T02:59:24.000Z</published>
    <updated>2018-10-25T03:14:58.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>Swift代理协议的安全使用</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwk840t3k2j30vi0frglr.jpg" alt=""></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Swift下，使用代理协议，并且检验代理对象的存在和协议函数是否被实现。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>可空链式调用（Optional Chaining）是一种可以请求和调用属性、方法及下标的过程，它的可空性体现于请求或调用的目标当前可能为空（nil）。如果可空的目标有值，那么调用就会成功；如果选择的目标为空（nil），那么这种调用将返回空（nil）。多个连续的调用可以被链接在一起形成一个调用链，如果其中任何一个节点为空（nil）将导致整个链调用失败。</p><blockquote><p>注意： Swift 的可空链式调用和 Objective-C 中的消息为空有些相像，但是 Swift 可以使用在任意类型中，并且能够检查调用是否成功。</p></blockquote><h2 id="空链式（Optional-Chaining）的使用之一"><a href="#空链式（Optional-Chaining）的使用之一" class="headerlink" title="空链式（Optional Chaining）的使用之一"></a>空链式（Optional Chaining）的使用之一</h2><p>在Swift中空链式的有个实用例子，就是编写代理的时候。当触发协议方法的时候，因为OC是消息型语言，所以必须要判断这个实例是否存在并且要判断当前方法是否被实现，不然没有实现的话，Runtime期间，就可能会报错。又因为OC几乎所以的类都是继承基类NSObject，而根类<code>NSObject</code>实现了其协议<code>NSObject</code>的协议方法<code>respondsToSelector:</code>,该方法可以判断某个方法实现的。如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 判断添加了代理对象，并且该对象实现了某个协议方法</span><br><span class="line">if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(protocalMethod)]) &#123;</span><br><span class="line">    [self.delegate protocalMethod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在Swift语言中，并未要求继承某个根类。并且也未提供某个方法去不判断某个方法是否被实现。其实因为Swift的语言一个特性–可选性，就很好解决这些问题了。正如上方的描述，如果其中任何一个节点为空（nil）将导致整个链调用失败。如下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.delegate?.<span class="type">SwiftProtocolTest</span>?()</span><br></pre></td></tr></table></figure></p><p>当判读使用有代理对象的时候，只需在属性<code>delegate</code>添加”?”就行，而需要判断某个函数是否实现只需在函数名和()之间添加”?”就行。</p><p>提示：本文delegate在Swift和OC的对比可以查看 <a href="https://github.com/wunanxyz/SwiftDelegateUsage.git" target="_blank" rel="noopener">github 代码</a></p><p>友情提示：</p><ul><li><a href="https://developer.apple.com/documentation/swift/optional" target="_blank" rel="noopener">Apple-optional文档</a></li><li><a href="https://developer.apple.com/documentation/swift/cocoa_design_patterns/using_delegates_to_customize_object_behavior" target="_blank" rel="noopener">using_delegates_to_customize_object_behavior</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述: 在Swift下，使用代理协议，并且检验代理对象的存在和协议函数是否被实现。
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="Swift" scheme="http://www.wunan520.cn/categories/iOS/Swift/"/>
    
      <category term="delegate" scheme="http://www.wunan520.cn/categories/iOS/Swift/delegate/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="Swift" scheme="http://www.wunan520.cn/tags/Swift/"/>
    
      <category term="delegate" scheme="http://www.wunan520.cn/tags/delegate/"/>
    
  </entry>
  
  <entry>
    <title>开发环境下PP文件的创建</title>
    <link href="http://www.wunan520.cn/2018/10/23/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8BPP%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>http://www.wunan520.cn/2018/10/23/开发环境下PP文件的创建/</id>
    <published>2018-10-23T09:26:07.000Z</published>
    <updated>2018-10-25T03:14:59.960Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a03441753c443?w=396&amp;h=215&amp;f=jpeg&amp;s=5234" alt=""></p><p>开发环境下Provisioning Profile文件的创建。<br>当我们在做iOS开发的时候,总是添加很多证书，来保证安全性。Provisioning Profile我们又称PP文件。这个文件将证书、App Id和设备相关联。本章节就是教大家如何创建开发环境下的PP文件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a034419938f4e?w=240&amp;h=240&amp;f=jpeg&amp;s=7699" alt=""></p><ol><li>通过该<code>Certificates,Identifiers&amp;Profiles</code>–&gt; <code>Provisioning Profiles</code>–&gt; <code>Development</code>路径，找到Profile文件的列表页面。添加<code>+</code>准备添加新的PP文件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a034419af214f?w=1560&amp;h=1410&amp;f=jpeg&amp;s=160699" alt=""></li></ol><p>2.选择证书的类型，这里选择开发证书。<br><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a03441995e24f?w=1572&amp;h=774&amp;f=jpeg&amp;s=163514" alt=""></p><p>3.选择APPID&amp;证书&amp;设备。</p><p>  3.1 选择对应的 <code>APP ID</code><br>  <img src="https://user-gold-cdn.xitu.io/2018/10/23/166a03442313878b?w=1576&amp;h=860&amp;f=jpeg&amp;s=193482" alt=""></p><p>  3.2 选择对应的证书<br>  <img src="https://user-gold-cdn.xitu.io/2018/10/23/166a034424596e55?w=1572&amp;h=1040&amp;f=jpeg&amp;s=172776" alt=""></p><p>  3.3 选择可以安装软件的设备号，设备号也就是每个硬件设备的序列号。<br><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a0344b02f0e54?w=1578&amp;h=1434&amp;f=jpeg&amp;s=202475" alt=""></p><ol start="4"><li>填写这个PP文件的名称。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a0344b03ead74?w=1576&amp;h=844&amp;f=jpeg&amp;s=168356" alt=""></p><ol start="5"><li>走到这步，说明已经安装成功。点击按钮<code>Download</code>就可以下载了。</li></ol><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwi9kmpldyj317y0r4tdd.jpg" alt=""></p><p>over，是不是很简单。正式环境的PP文件，也是大同小异。有时间也出篇教程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:开发环境下Provisioning Profile文件的创建。
当我们在做iOS开发的时候,总是添加很多证书，来保证安全性。Provisioning Profile我们又称PP文件。这个文件将证书、App Id和设备相关联。本章节就是教大家如何创建开发环境下的PP文件。
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="PP文件" scheme="http://www.wunan520.cn/categories/iOS/PP%E6%96%87%E4%BB%B6/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="PP文件" scheme="http://www.wunan520.cn/tags/PP%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发实用软件之NWPusher</title>
    <link href="http://www.wunan520.cn/2018/10/23/iOS%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%B9%8BNWPusher/"/>
    <id>http://www.wunan520.cn/2018/10/23/iOS开发实用软件之NWPusher/</id>
    <published>2018-10-23T06:08:39.000Z</published>
    <updated>2018-10-23T07:55:00.899Z</updated>
    
    <content type="html"><![CDATA[<p>一个App获取到一个Push内容。必须是服务器拿着对应token和需要的消息内容发给苹果服务器，然后由苹果服务器推送给用户。作为前端开发人员，为了学习Push，去搭建一个服务器，还是很耗时的。想了解<a href="https://www.wunan520.cn/2018/10/17/PrincipleOfPush/">iOS推送系列之Push的工作原理</a>，可以查看这篇博客。</p><p>现在有个软件NWPusher可以模拟服务器发送Push。为我们研究Push提供了便利，我们一起来了解下。</p><h4 id="一、软件的安装"><a href="#一、软件的安装" class="headerlink" title="一、软件的安装"></a>一、软件的安装</h4><p>多种方式：</p><ol><li><p>使用<a href="https://github.com/Homebrew/homebrew-cask" target="_blank" rel="noopener">Homebrew cask</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install pusher</span><br></pre></td></tr></table></figure><ol start="2"><li><p>直接安装Pusher.app</p><p>可以下载软件：<a href="https://github.com/noodlewerk/NWPusher/releases/latest" target="_blank" rel="noopener">最新的下载地址</a></p></li></ol></li><li><p>NWPusher可以可以当做<code>framework</code>使用。<br>这个也有2种方式。</p><p>3.1 使用<code>CocoaPods</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;NWPusher&apos;, &apos;~&gt; 0.7.0&apos;</span><br></pre></td></tr></table></figure><p>3.2 使用<code>Carthage</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github &quot;noodlewerk/NWPusher&quot;</span><br></pre></td></tr></table></figure><h4 id="二、软件的介绍"><a href="#二、软件的介绍" class="headerlink" title="二、软件的介绍"></a>二、软件的介绍</h4><p>软件界面如图：<br><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669f86250c2e9a2?w=1224&amp;h=668&amp;f=jpeg&amp;s=185349" alt=""><br>如图所示：</p><ul><li>我们需要选择<strong>相应的Push开发测试证书</strong>，如果创建证书，可以查看<a href="https://www.wunan520.cn/2018/10/22/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83Push%E8%AF%81%E4%B9%A6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%9B%BE%E6%96%87%E6%B5%81%E7%A8%8B/">开发环境Push证书的创建图文流程</a>这篇博客了解相应的知识。</li><li>添加相应的deviceToken</li><li>选择过期时间:有8种选择。<ul><li>Expiry:None : 不会过期</li><li>immediate(0) :立即</li><li>1 minute :1分钟时</li><li>5 minutes :5分钟时</li><li>1 hour :1小时时</li><li>1 day :1天时</li><li>Far past(1) :遥远的过去</li><li>Far future: :永远</li></ul></li><li>选择优先级：3个<ul><li>Pirority:None :没有优先级</li><li>Conserve power(5) : 电量优先</li><li>immediately(10) : 立刻，其优先级最高</li></ul></li><li>Payload输入内容就是我们需要传送的数据了：这个数据传输以JSON的格式存储。是必要按照APNs发送的Push格式的。Push消息常用的key如下：<ul><li><strong>aps</strong>,是其value是我们需要传送的内容。</li><li><strong>alert</strong>,是其value就是弹出框需要展示的内容。</li><li><strong>badge</strong>,是其value就是APP icon，展示的信息个数。</li><li><strong>sound</strong>,是其value就是表示当有Push消息的时候，是否需要声音提示。</li></ul></li></ul></li></ol><p>另外，alert中value值，可以是字符串，可以是字典。这个字典可以使用多对值，比如其key是<code>title</code>,<code>subtitle</code>,<code>body</code>等。其格式如下<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"aps"</span>: &#123;</span><br><span class="line"><span class="attr">"alert"</span>: &#123;</span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"title"</span>,</span><br><span class="line"><span class="attr">"subtitle"</span>: <span class="string">"subTitle"</span>,</span><br><span class="line"><span class="attr">"body"</span>: <span class="string">"body"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"badge"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"sound"</span>: <span class="string">"default"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更多关于<code>aps</code>,<code>alert</code>,<code>sound</code>等可以查看官网：<a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification?language=objc" target="_blank" rel="noopener">Generating a Remote Notification</a></p><p>所以都填选好，点击按钮 Push。就可以发送了。其发送状态，边上都有发布状态的提示信息。</p><p>友情链接：</p><ul><li><a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification?language=objc" target="_blank" rel="noopener">Generating a Remote Notification</a></li><li><a href="https://github.com/noodlewerk/NWPusher" target="_blank" rel="noopener">NWPusher github地址</a></li><li><a href="https://www.imooc.com/video/15121" target="_blank" rel="noopener">搭建Push环境</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:软件NWPusher可以模拟服务器发送Push。为我们研究Push提供了便利，我们一起来了解下。
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="push" scheme="http://www.wunan520.cn/categories/iOS/push/"/>
    
    
      <category term="push" scheme="http://www.wunan520.cn/tags/push/"/>
    
      <category term="模拟" scheme="http://www.wunan520.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>开发环境Push证书的创建图文流程</title>
    <link href="http://www.wunan520.cn/2018/10/22/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83Push%E8%AF%81%E4%B9%A6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%9B%BE%E6%96%87%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.wunan520.cn/2018/10/22/开发环境Push证书的创建图文流程/</id>
    <published>2018-10-22T07:45:44.000Z</published>
    <updated>2018-10-22T08:25:02.965Z</updated>
    
    <content type="html"><![CDATA[<p>当写Push的时候，必须有相应的证书。而证书的创建也是个知识点。今天以图文的形式写个相关的证书创建的流程。<br>生成对应的APP ID 和证书</p><h4 id="一-添加App-ID"><a href="#一-添加App-ID" class="headerlink" title="一.添加App ID"></a>一.添加App ID</h4><h5 id="1-进入苹果开发中心的App-Id"><a href="#1-进入苹果开发中心的App-Id" class="headerlink" title="1.进入苹果开发中心的App Id"></a>1.进入苹果开发中心的App Id</h5><ol><li>选择 <code>Cerfificates,Identifiers&amp;Profiles</code> –&gt; <code>Identifiers</code> –&gt; <code>App IDs</code></li><li>点击右上角的<code>+</code>来添加证书。<div align="center"><br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwgugjdwesj31i812ajxr.jpg" width="500" hegiht="343" align="center"><br></div></li></ol><h5 id="2-注册一个App-ID"><a href="#2-注册一个App-ID" class="headerlink" title="2.注册一个App ID"></a>2.注册一个<code>App ID</code></h5><p> 在这个页面填写和选择相应的</p><ol><li><p>在<code>App ID Description</code> –&gt; <code>name</code> 输入相应的App Name</p><div align="center"><br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwgvy133lhj31iu11ywmg.jpg" width="500" hegiht="343" align="center"><br></div></li><li><p>在<code>App ID Suffix</code> –&gt; <code>Explicit App ID</code> –&gt; <code>Bundle ID</code> 输入相应的<code>bundle id</code></p><div align="center"><br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwgwdc07xsj31iq12e109.jpg" width="500" hegiht="343" align="center"><br></div></li><li><p>在 App Services –&gt; <code>Enable Services</code> 选择相应的服务。这里选项 <code>Push Notifications</code>。点击<code>continue</code>生成对应的app id</p><div align="center"><br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwgwdy5bcij30yg13wwjg.jpg" width="500" hegiht="343" align="center"><br></div></li></ol><h5 id="3-确认App-Id，这个页面不需要填选任何内容。检查下即将创建的App-ID的内容，是否正确。"><a href="#3-确认App-Id，这个页面不需要填选任何内容。检查下即将创建的App-ID的内容，是否正确。" class="headerlink" title="3. 确认App Id，这个页面不需要填选任何内容。检查下即将创建的App ID的内容，是否正确。"></a>3. 确认<code>App Id</code>，这个页面不需要填选任何内容。检查下即将创建的App ID的内容，是否正确。</h5><div align="center"><br> <img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwgughjyfcj315214u45t.jpg" width="500" hegiht="343" align="center"><br></div> <div align="center"><br>  <img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwguggyr7pj314y0js76k.jpg" width="500" hegiht="343" align="center"><br> </div><p>点击<code>Rigister</code>注册。</p><h5 id="4-完成操作"><a href="#4-完成操作" class="headerlink" title="4. 完成操作"></a>4. 完成操作</h5><p>点击<code>Done</code>完成操作。这个时候<code>App ID</code>就创建成功了。</p><div align="center"><br> <img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwguggjrjtj31e612eahy.jpg" width="500" hegiht="343" align="center"><br></div><br><div align="center"><br> <img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwgugfxc66j31cs0xwgpj.jpg" width="500" hegiht="343" align="center"><br></div><p>生成APP ID 之后，再生成对应的证书，用于身份认证。</p><h3 id="二-进入苹果开发中心的证书"><a href="#二-进入苹果开发中心的证书" class="headerlink" title="二. 进入苹果开发中心的证书"></a>二. 进入苹果开发中心的证书</h3><h5 id="1-进入开发环境证书列表页"><a href="#1-进入开发环境证书列表页" class="headerlink" title="1. 进入开发环境证书列表页"></a>1. 进入开发环境证书列表页</h5><ol><li>选择 <code>Cerfificates,Identifiers&amp;Profiles</code> –&gt; <code>Cerfificates</code> –&gt; <code>Development</code></li><li>点击右上角的<code>+</code>来添加证书。<div align="center"><br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwgugfj4q2j31d80rqwih.jpg" width="500" hegiht="343" align="center"><br></div></li></ol><h6 id="2-选择证书类型"><a href="#2-选择证书类型" class="headerlink" title="2. 选择证书类型"></a>2. 选择证书类型</h6><p>2.1. 因为是需要添加推送证书，选择的证书了类型<code>Apple Push Notification server SSL(SandBox)</code>。然后下一步</p><div align="center"><br> <img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwgugf3lvuj31d20yeqaf.jpg" width="500" hegiht="343" align="center"><br></div><br>2.2. 选择添加<code>App Id</code><br><div align="center"><br> <img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwgx3k81epj31840o40y2.jpg" width="500" hegiht="343" align="center"><br></div><h6 id="3-提交点子信息证书的请求"><a href="#3-提交点子信息证书的请求" class="headerlink" title="3. 提交点子信息证书的请求"></a>3. 提交点子信息证书的请求</h6><p>相应证书创建电子信息证书步骤是提示,点击<code>continue</code>.</p><div align="center"><br> <img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwgugejkp1j318k0y0jyu.jpg" width="500" hegiht="343" align="center"><br></div><h6 id="4-生成"><a href="#4-生成" class="headerlink" title="4. 生成"></a>4. 生成</h6><p>选择添加本地请求文件。如何创建请求文件，从下面的第三部分：创建电子信息证书的步骤获取。</p><div align="center"><br> <img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwgx8l33zuj318o0sk0yr.jpg" width="500" hegiht="343" align="center"><br></div><h6 id="5-下载"><a href="#5-下载" class="headerlink" title="5. 下载"></a>5. 下载</h6><p>证书已经生成成功，下载到本地。</p><div align="center"><br> <img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwgxti05fjj31940wydma.jpg" width="500" hegiht="343" align="center"><br></div><h5 id="6-添加到钥匙串"><a href="#6-添加到钥匙串" class="headerlink" title="6. 添加到钥匙串"></a>6. 添加到钥匙串</h5><p>下载的文件<code>aps_development.cer</code>,双击这个文件来安装。安装成功就会跳转到钥匙串的证书部分，表示安装成功。</p><div align="center"><br> <img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwgymmux4oj315g0pwq7q.jpg" width="500" hegiht="343" align="center"><br></div><h4 id="三-电子证书请求文件的创建。"><a href="#三-电子证书请求文件的创建。" class="headerlink" title="三. 电子证书请求文件的创建。"></a>三. 电子证书请求文件的创建。</h4><ol><li><p>在进入钥匙串中</p><div align="center"><br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwgxhqc919j313m0mkq88.jpg" width="500" hegiht="343" align="center"><br></div></li><li><p>创建电子签名请求</p><p>  a. <code>钥匙串访问</code> –&gt; <code>证书助理</code> –&gt; <code>从证书颁发机构请求...</code></p><div align="center"><br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwgxhs0kezj30ty0em4mk.jpg" width="500" hegiht="343" align="center"><br></div><br>b. 填写添加邮件,选择<code>存储到磁盘</code>。点击<code>继续</code>,选择保存到本地的位置，保存到本地。<br><div align="center"><br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwgxht28tuj30ya0oeae9.jpg" width="500" hegiht="343" align="center"><br></div><br>c.本地的电子签名请求<br><div align="center"><br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwgy7ryal1j30je04g74q.jpg" width="500" hegiht="343" align="center"><br></div></li></ol><p>以上就是整个开发环境Push证书的创建过程。</p><p>参考:</p><ul><li><a href="https://www.imooc.com/video/15120" target="_blank" rel="noopener">搭建Push环境上</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
当写Push的时候，必须有相应的证书。而证书的创建也是个知识点。今天以图文的形式写个相关的证书创建的流程。
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="push" scheme="http://www.wunan520.cn/categories/iOS/push/"/>
    
      <category term="证书" scheme="http://www.wunan520.cn/categories/iOS/push/%E8%AF%81%E4%B9%A6/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="push" scheme="http://www.wunan520.cn/tags/push/"/>
    
      <category term="证书" scheme="http://www.wunan520.cn/tags/%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Swift中Class和Struct异同</title>
    <link href="http://www.wunan520.cn/2018/10/17/Swift%E4%B8%ADClass%E5%92%8CStruct%E5%BC%82%E5%90%8C/"/>
    <id>http://www.wunan520.cn/2018/10/17/Swift中Class和Struct异同/</id>
    <published>2018-10-17T09:46:08.000Z</published>
    <updated>2018-10-25T03:18:18.665Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1683361-ebfc93018b2012ba.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Swift 中类和结构体有很多<strong>共同点</strong>。共同处在于：</p><ul><li>定义属性用于存储值</li><li>定义方法用于提供功能</li><li>定义下标操作使得可以通过<strong>下标</strong>语法来访问实例所包含的值</li><li>定义<strong>构造器</strong>用于生成初始化值</li><li>通过<strong>扩展</strong>以增加默认实现的功能</li><li>实现<strong>协议</strong>以提供某种标准功能</li></ul><p>与结构体相比，类还有如下的附加功能：</p><ul><li><strong>继承</strong>允许一个类继承另一个类的特征</li><li>类型转换允许在运行时检查和解释一个类实例的类型</li><li><strong>析构器</strong>允许一个类实例释放任何其所被分配的资源</li><li>引用计数允许对一个类的多次<strong>引用</strong></li></ul><p><strong>Tip:</strong> 类的对象是<strong>引用类型</strong>，而结构体是<strong>值类型</strong>。所以类的赋值是传递引用，结构体则是Copy传值,不是使用引用计数。</p><p>类为支持的额外功能会增加其复杂性。一般,更倾向使用选择结构和枚举,因为他们更容易理解,而类，则当再在合适和必要的时候使用。实际上,这意味着大多数的自定义数据类型定义为结构和枚举就可以了。更详细的比较,<a href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes" target="_blank" rel="noopener">请参阅结构和类之间的选择</a>。<br></p><h3 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h3><p>类和结构体有着类似的定义方式。我们通过关键字<code>class</code>和<code>struct</code>来分别表示类和结构体，并在一对大括号中定义它们的具体内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里定义类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里定义结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>在定义一个新类或者结构体的时候，实际上是定义了一个新的 Swift 类型。因此请使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），以便符合标准 Swift 类型的大写命名风格（如String，Int和Bool）。相反的，请使用lowerCamelCase这种方式为<strong>属性和方法</strong>命名（如framerate和incrementCount），以便和类型名区分。</p></blockquote><p>以下是定义结构体和定义类的示例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolution = <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="类和结构体实例"><a href="#类和结构体实例" class="headerlink" title="类和结构体实例"></a>类和结构体实例</h3><p>生成结构体和类实例的语法非常相似：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someResolution = <span class="type">Resolution</span>()</span><br><span class="line"><span class="keyword">let</span> someVideoMode = <span class="type">VideoMode</span>()</span><br></pre></td></tr></table></figure></p><p>结构体和类都使用<strong>构造器</strong>语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对<strong>空括号</strong>，如Resolution()或VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为<strong>默认值</strong>。</p><h3 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h3><p>通过使用点语法,访问实例的属性.<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someResolution is <span class="subst">\(someResolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "The width of someResolution is 0"</span></span><br></pre></td></tr></table></figure></p><p>可以访问子属性<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is <span class="subst">\(someVideoMode.resolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "The width of someVideoMode is 0"</span></span><br></pre></td></tr></table></figure></p><p>可以使用点语法为变量属性赋值<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">someVideoMode.resolution.width = <span class="number">1280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is now <span class="subst">\(someVideoMode.resolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "The width of someVideoMode is now 1280"</span></span><br></pre></td></tr></table></figure></p><h3 id="结构体类型的成员逐一构造器"><a href="#结构体类型的成员逐一构造器" class="headerlink" title="结构体类型的成员逐一构造器"></a>结构体类型的成员逐一构造器</h3><p>所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vga = <span class="type">Resolution</span>(width:<span class="number">640</span>, height: <span class="number">480</span>)</span><br></pre></td></tr></table></figure></p><p>与结构体不同，类实例<strong>没有默认的成员逐一构造器</strong>。</p><h3 id="结构体和枚举是值类型"><a href="#结构体和枚举是值类型" class="headerlink" title="结构体和枚举是值类型"></a>结构体和枚举是值类型</h3><p><em>值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。</em></p><p>实际上，在Swift中，<strong>所有的基本类型</strong>：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。</p><p>在<code>Swift</code>中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会<strong>被复制</strong>。</p><h3 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h3><p>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。</p><h3 id="恒等运算符"><a href="#恒等运算符" class="headerlink" title="恒等运算符"></a>恒等运算符</h3><p>因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）<br>如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符：</p><ul><li>等价于（===）</li><li>不等价于（!==）</li></ul><p>运用这两个运算符检测两个常量或者变量是否<strong>引用同一个实例</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tenEighty === alsoTenEighty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"tenEighty and alsoTenEighty refer to the same Resolution instance."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印 "tenEighty and alsoTenEighty refer to the same Resolution instance."</span></span><br></pre></td></tr></table></figure><p>请注意，“等价于”（用三个等号表示，===）与“等于”（用两个等号表示，==）的不同：</p><ul><li>“等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。</li><li>“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法。</li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><code>C</code>，<code>C++</code> 或者<code>Objective-C</code>语言使用指针来引用内存中的地址。一个引用某个引用类型实例的 <code>Swift</code> 常量或者变量，与<code>C</code>语言中的指针类似，<strong>但是并不直接指向某个内存地址</strong>，也不要求你使用星号（*）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。</p><h3 id="类和结构体的选择"><a href="#类和结构体的选择" class="headerlink" title="类和结构体的选择"></a>类和结构体的选择</h3><p>结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。</p><p>按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体：</p><ul><li>该数据结构的主要目的是用来封装<strong>少量</strong>相关<strong>简单</strong>数据值。</li><li>有理由预计该数据结构的实例在<strong>被赋值或传递</strong>时，封装的数据将会<strong>被拷贝而不是被引用</strong>。</li><li>该数据结构中储存的值类型属性，也<strong>应该被拷贝</strong>，而不是被引用。</li><li>该数据结构<strong>不需要去继承</strong>另一个既有类型的属性或者行为。</li></ul><p>举例来说，以下情境中适合使用结构体：</p><ul><li>几何形状的大小，封装一个width属性和height属性，两者均为Double类型。</li><li>一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。</li><li>三维坐标系内一点，封装x，y和z属性，三者均为Double类型。</li></ul><p>在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。</p><h3 id="字符串、数组、和字典类型的赋值与复制行为"><a href="#字符串、数组、和字典类型的赋值与复制行为" class="headerlink" title="字符串、数组、和字典类型的赋值与复制行为"></a>字符串、数组、和字典类型的赋值与复制行为</h3><p><code>Swift</code>中，所以基本类型，诸如String，Array和Dictionary类型均以<strong>结构体</strong>的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。</p><p><code>Objective-C</code> 中NSString，NSArray和NSDictionary类型均以<strong>类</strong>的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。</p><blockquote><p><strong>注意</strong><br>以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在<strong>绝对必要时才执行实际的拷贝</strong>。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。</p></blockquote><p>参考：</p><ul><li><a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html" target="_blank" rel="noopener">苹果 swift - Structures and Classes</a></li><li><a href="http://www.runoob.com/manual/gitbook/swift3/source/_book/chapter2/09_Classes_and_Structures.html#comparing_classes_and_structures" target="_blank" rel="noopener">中文翻译类与结构体</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:	Swift语言中Class的定义和Struct的定义。以及二者创建的对象的异同。
&lt;/p&gt;

    
    </summary>
    
      <category term="Swift" scheme="http://www.wunan520.cn/categories/Swift/"/>
    
      <category term="Class" scheme="http://www.wunan520.cn/categories/Swift/Class/"/>
    
      <category term="Struct" scheme="http://www.wunan520.cn/categories/Swift/Struct/"/>
    
    
      <category term="Swift" scheme="http://www.wunan520.cn/tags/Swift/"/>
    
      <category term="Class" scheme="http://www.wunan520.cn/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>iOS推送系列之Push的工作原理</title>
    <link href="http://www.wunan520.cn/2018/10/17/PrincipleOfPush/"/>
    <id>http://www.wunan520.cn/2018/10/17/PrincipleOfPush/</id>
    <published>2018-10-17T03:40:53.000Z</published>
    <updated>2018-10-22T08:08:55.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Push的工作原理"><a href="#Push的工作原理" class="headerlink" title="Push的工作原理"></a>Push的工作原理</h3><p>  要理解Push的工作原理，我们必须要知道几个知识点。</p><ul><li>设备是如何和APNs保持连接的。</li><li>APNs如何识别需要推送的设备。</li></ul><p>&emsp;&emsp;APNs可以推送给设备Push消息，是因为设备(iPhone、iPad)和APNs有一个长连接的通道。<br>&emsp;&emsp;iOS的Push通道是一个独立的长连接通道，并且是唯一的一个通道，由iOS系统独立维护。也就是说每一个手机系统，每次开机后，手机后台就会发出一个长连接，连接到苹果服务器(APNs)。<br>当APNs收到新的Push通知的时候就会把通知推送给应用设备。</p><p><img src="https://upload-images.jianshu.io/upload_images/1683361-b84ca1f2f30f0748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="苹果官方网站的原理图"></p><p>通过官方的原理图四个身份</p><ul><li>Provider：我们的服务器sever</li><li>APNs：苹果服务器</li><li>Device(设备)：iPhone、iPad</li><li>Client App：客户端的app</li></ul><p><strong>Tip</strong>：苹果可以省电省流量，原因之一有<strong>Push网络通道是唯一的一个</strong>，并且苹果公司来维护。</p><p><img src="https://upload-images.jianshu.io/upload_images/1683361-36e756ff58c58570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="push的工作原理"></p><p>总结下大致流程</p><ol><li>设备打开某个App后，会生成唯一的<strong>一个token</strong>，并把这个token上传给我们自己的服务器，我们的服务器有了token，就可以向我们的app推送通知了，这个是前提。但是这个通知并不能直接推送给我们的设备，而是要推送给苹果的服务器。</li><li>我们的服务器会将token和推送的内容，一起推送给苹果的服务器。</li><li>苹果服务器会根据token定位到设备,将push推送给设备。</li><li>设备拿到这个push，就会知道是哪个app。然后就可以将这个通知推送到具体的app。</li></ol><p>参考资料</p><ul><li><a href="https://www.imooc.com/video/15117" target="_blank" rel="noopener">push工作原理</a></li><li><a href="https://developer.apple.com/documentation/usernotifications?language=objc" target="_blank" rel="noopener">苹果官方push内容</a></li><li><a href="http://www.open-open.com/lib/view/open1462951879679.html" target="_blank" rel="noopener">iOS远程推送原理及实现过程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:	iOS的Push的原理。关于设备如何和APNs建立连接。整个推送的步骤等，一网打尽。
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="push" scheme="http://www.wunan520.cn/categories/iOS/push/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="push" scheme="http://www.wunan520.cn/tags/push/"/>
    
  </entry>
  
</feed>
