<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吴楠的小栈</title>
  
  <subtitle>study hard , study smart</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wunan520.cn/"/>
  <updated>2018-10-17T23:49:25.819Z</updated>
  <id>http://www.wunan520.cn/</id>
  
  <author>
    <name>EmilyWu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift中Class和Struct异同</title>
    <link href="http://www.wunan520.cn/2018/10/17/Swift%E4%B8%ADClass%E5%92%8CStruct%E5%BC%82%E5%90%8C/"/>
    <id>http://www.wunan520.cn/2018/10/17/Swift中Class和Struct异同/</id>
    <published>2018-10-17T09:46:08.000Z</published>
    <updated>2018-10-17T23:49:25.819Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1683361-ebfc93018b2012ba.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Swift 中类和结构体有很多<strong>共同点</strong>。共同处在于：</p><ul><li>定义属性用于存储值</li><li>定义方法用于提供功能</li><li>定义下标操作使得可以通过<strong>下标</strong>语法来访问实例所包含的值</li><li>定义<strong>构造器</strong>用于生成初始化值</li><li>通过<strong>扩展</strong>以增加默认实现的功能</li><li>实现<strong>协议</strong>以提供某种标准功能</li></ul><p>与结构体相比，类还有如下的附加功能：</p><ul><li><strong>继承</strong>允许一个类继承另一个类的特征</li><li>类型转换允许在运行时检查和解释一个类实例的类型</li><li><strong>析构器</strong>允许一个类实例释放任何其所被分配的资源</li><li>引用计数允许对一个类的多次<strong>引用</strong></li></ul><p><strong>Tip:</strong> 类的对象是<strong>引用类型</strong>，而结构体是<strong>值类型</strong>。所以类的赋值是传递引用，结构体则是Copy传值,不是使用引用计数。</p><p>类为支持的额外功能会增加其复杂性。一般,更倾向使用选择结构和枚举,因为他们更容易理解,而类，则当再在合适和必要的时候使用。实际上,这意味着大多数的自定义数据类型定义为结构和枚举就可以了。更详细的比较,<a href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes" target="_blank" rel="noopener">请参阅结构和类之间的选择</a>。<br></p><h3 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h3><p>类和结构体有着类似的定义方式。我们通过关键字<code>class</code>和<code>struct</code>来分别表示类和结构体，并在一对大括号中定义它们的具体内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里定义类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里定义结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>在定义一个新类或者结构体的时候，实际上是定义了一个新的 Swift 类型。因此请使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），以便符合标准 Swift 类型的大写命名风格（如String，Int和Bool）。相反的，请使用lowerCamelCase这种方式为<strong>属性和方法</strong>命名（如framerate和incrementCount），以便和类型名区分。</p></blockquote><p>以下是定义结构体和定义类的示例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolution = <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="类和结构体实例"><a href="#类和结构体实例" class="headerlink" title="类和结构体实例"></a>类和结构体实例</h3><p>生成结构体和类实例的语法非常相似：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someResolution = <span class="type">Resolution</span>()</span><br><span class="line"><span class="keyword">let</span> someVideoMode = <span class="type">VideoMode</span>()</span><br></pre></td></tr></table></figure></p><p>结构体和类都使用<strong>构造器</strong>语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对<strong>空括号</strong>，如Resolution()或VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为<strong>默认值</strong>。</p><h3 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h3><p>通过使用点语法,访问实例的属性.<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someResolution is <span class="subst">\(someResolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "The width of someResolution is 0"</span></span><br></pre></td></tr></table></figure></p><p>可以访问子属性<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is <span class="subst">\(someVideoMode.resolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "The width of someVideoMode is 0"</span></span><br></pre></td></tr></table></figure></p><p>可以使用点语法为变量属性赋值<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">someVideoMode.resolution.width = <span class="number">1280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is now <span class="subst">\(someVideoMode.resolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 "The width of someVideoMode is now 1280"</span></span><br></pre></td></tr></table></figure></p><h3 id="结构体类型的成员逐一构造器"><a href="#结构体类型的成员逐一构造器" class="headerlink" title="结构体类型的成员逐一构造器"></a>结构体类型的成员逐一构造器</h3><p>所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vga = <span class="type">Resolution</span>(width:<span class="number">640</span>, height: <span class="number">480</span>)</span><br></pre></td></tr></table></figure></p><p>与结构体不同，类实例<strong>没有默认的成员逐一构造器</strong>。</p><h3 id="结构体和枚举是值类型"><a href="#结构体和枚举是值类型" class="headerlink" title="结构体和枚举是值类型"></a>结构体和枚举是值类型</h3><p><em>值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。</em></p><p>实际上，在Swift中，<strong>所有的基本类型</strong>：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。</p><p>在<code>Swift</code>中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会<strong>被复制</strong>。</p><h3 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h3><p>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。</p><h3 id="恒等运算符"><a href="#恒等运算符" class="headerlink" title="恒等运算符"></a>恒等运算符</h3><p>因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）<br>如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符：</p><ul><li>等价于（===）</li><li>不等价于（!==）</li></ul><p>运用这两个运算符检测两个常量或者变量是否<strong>引用同一个实例</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tenEighty === alsoTenEighty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"tenEighty and alsoTenEighty refer to the same Resolution instance."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印 "tenEighty and alsoTenEighty refer to the same Resolution instance."</span></span><br></pre></td></tr></table></figure><p>请注意，“等价于”（用三个等号表示，===）与“等于”（用两个等号表示，==）的不同：</p><ul><li>“等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。</li><li>“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法。</li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><code>C</code>，<code>C++</code> 或者<code>Objective-C</code>语言使用指针来引用内存中的地址。一个引用某个引用类型实例的 <code>Swift</code> 常量或者变量，与<code>C</code>语言中的指针类似，<strong>但是并不直接指向某个内存地址</strong>，也不要求你使用星号（*）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。</p><h3 id="类和结构体的选择"><a href="#类和结构体的选择" class="headerlink" title="类和结构体的选择"></a>类和结构体的选择</h3><p>结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。</p><p>按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体：</p><ul><li>该数据结构的主要目的是用来封装<strong>少量</strong>相关<strong>简单</strong>数据值。</li><li>有理由预计该数据结构的实例在<strong>被赋值或传递</strong>时，封装的数据将会<strong>被拷贝而不是被引用</strong>。</li><li>该数据结构中储存的值类型属性，也<strong>应该被拷贝</strong>，而不是被引用。</li><li>该数据结构<strong>不需要去继承</strong>另一个既有类型的属性或者行为。</li></ul><p>举例来说，以下情境中适合使用结构体：</p><ul><li>几何形状的大小，封装一个width属性和height属性，两者均为Double类型。</li><li>一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。</li><li>三维坐标系内一点，封装x，y和z属性，三者均为Double类型。</li></ul><p>在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。</p><h3 id="字符串、数组、和字典类型的赋值与复制行为"><a href="#字符串、数组、和字典类型的赋值与复制行为" class="headerlink" title="字符串、数组、和字典类型的赋值与复制行为"></a>字符串、数组、和字典类型的赋值与复制行为</h3><p><code>Swift</code>中，所以基本类型，诸如String，Array和Dictionary类型均以<strong>结构体</strong>的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。</p><p><code>Objective-C</code> 中NSString，NSArray和NSDictionary类型均以<strong>类</strong>的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。</p><blockquote><p><strong>注意</strong><br>以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在<strong>绝对必要时才执行实际的拷贝</strong>。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。</p></blockquote><p>参考：</p><ul><li><a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html" target="_blank" rel="noopener">苹果 swift - Structures and Classes</a></li><li><a href="http://www.runoob.com/manual/gitbook/swift3/source/_book/chapter2/09_Classes_and_Structures.html#comparing_classes_and_structures" target="_blank" rel="noopener">中文翻译类与结构体</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:	Swift语言中Class的定义和Struct的定义。以及二者创建的对象的异同。
&lt;/p&gt;

    
    </summary>
    
      <category term="Swift" scheme="http://www.wunan520.cn/categories/Swift/"/>
    
      <category term="Class" scheme="http://www.wunan520.cn/categories/Swift/Class/"/>
    
      <category term="Struct" scheme="http://www.wunan520.cn/categories/Swift/Class/Struct/"/>
    
    
      <category term="Swift" scheme="http://www.wunan520.cn/tags/Swift/"/>
    
      <category term="对比" scheme="http://www.wunan520.cn/tags/%E5%AF%B9%E6%AF%94/"/>
    
      <category term="Class" scheme="http://www.wunan520.cn/tags/Class/"/>
    
      <category term="Struct" scheme="http://www.wunan520.cn/tags/Struct/"/>
    
  </entry>
  
  <entry>
    <title>iOS推送系列之Push的工作原理</title>
    <link href="http://www.wunan520.cn/2018/10/17/PrincipleOfPush/"/>
    <id>http://www.wunan520.cn/2018/10/17/PrincipleOfPush/</id>
    <published>2018-10-17T03:40:53.000Z</published>
    <updated>2018-10-17T23:55:04.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Push的工作原理"><a href="#Push的工作原理" class="headerlink" title="Push的工作原理"></a>Push的工作原理</h3><p>  要理解Push的工作原理，我们必须要知道几个知识点。</p><ul><li>设备是如何和APNs保持连接的。</li><li>APNs如何识别需要推送的设备。</li></ul><p>&emsp;&emsp;APNs可以推送给设备Push消息，是因为设备(iPhone、iPad)和APNs有一个长连接的通道。<br>&emsp;&emsp;iOS的Push通道是一个独立的长连接通道，并且是唯一的一个通道，由iOS系统独立维护。也就是说每一个手机系统，每次开机后，手机后台就会发出一个长连接，连接到苹果服务器(APNs)。<br>当APNs收到新的Push通知的时候就会把通知推送给应用设备。</p><p><img src="https://upload-images.jianshu.io/upload_images/1683361-b84ca1f2f30f0748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="苹果官方网站的原理图"></p><p>通过官方的原理图四个身份</p><ul><li>Provider：我们的服务器sever</li><li>APNs：苹果服务器</li><li>Device(设备)：iPhone、iPad</li><li>Client App：客户端的app</li></ul><p><strong>Tip</strong>：苹果可以省电省流量，原因之一有<strong>Push网络通道是唯一的一个</strong>，并且苹果公司来维护。</p><p><img src="https://upload-images.jianshu.io/upload_images/1683361-36e756ff58c58570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="push的工作原理"></p><p>总结下大致流程</p><ol><li>设备打开某个App后，会生成唯一的<strong>一个token</strong>，并把这个token上传给我们自己的服务器，我们的服务器有了token，就可以向我们的app推送通知了，这个是前提。但是这个通知并不能直接推送给我们的设备，而是要推送给苹果的服务器。</li><li>我们的服务器会将token和推送的内容，一起推送给苹果的服务器。</li><li>苹果服务器会根据token定位到设备,将push推送给设备。</li><li>设备拿到这个push，就会知道是哪个app。然后就可以将这个通知推送到具体的app。</li></ol><p>参考资料</p><ul><li><a href="https://www.imooc.com/video/15117" target="_blank" rel="noopener">push工作原理</a></li><li><a href="https://developer.apple.com/documentation/usernotifications?language=objc" target="_blank" rel="noopener">苹果官方push内容</a></li><li><a href="http://www.open-open.com/lib/view/open1462951879679.html" target="_blank" rel="noopener">iOS远程推送原理及实现过程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;color: #333333&quot;&gt;
概述:	iOS的Push的原理。关于设备如何和APNs建立连接。整个推送的步骤等，一网打尽。
&lt;/p&gt;

    
    </summary>
    
      <category term="iOS" scheme="http://www.wunan520.cn/categories/iOS/"/>
    
      <category term="push相关" scheme="http://www.wunan520.cn/categories/iOS/push%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="iOS" scheme="http://www.wunan520.cn/tags/iOS/"/>
    
      <category term="push" scheme="http://www.wunan520.cn/tags/push/"/>
    
  </entry>
  
  <entry>
    <title>SecondPage</title>
    <link href="http://www.wunan520.cn/2018/10/06/NotNeed/SecondPage/"/>
    <id>http://www.wunan520.cn/2018/10/06/NotNeed/SecondPage/</id>
    <published>2018-10-05T20:31:12.000Z</published>
    <updated>2018-10-05T21:00:28.489Z</updated>
    
    <content type="html"><![CDATA[<p>SecondPageTest<br>SecondPageTest<br>SecondPageTest<br>SecondPageTest<br>SecondPageTest</p>]]></content>
    
    <summary type="html">
    
      descriptiontest ，SecondPageTest
    
    </summary>
    
      <category term="Test" scheme="http://www.wunan520.cn/categories/Test/"/>
    
    
      <category term="标签2" scheme="http://www.wunan520.cn/tags/%E6%A0%87%E7%AD%BE2/"/>
    
  </entry>
  
  <entry>
    <title>MyFristBlogTest</title>
    <link href="http://www.wunan520.cn/2018/10/05/NotNeed/MyFristBlogTest/"/>
    <id>http://www.wunan520.cn/2018/10/05/NotNeed/MyFristBlogTest/</id>
    <published>2018-10-05T15:08:30.000Z</published>
    <updated>2018-10-05T20:59:02.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h1><p>这是我的第一篇文章:)<br>22lfldkfldkfdkfk</p><p> <a href="https://www.baidu.com" target="_blank" rel="noopener">连接测试 2222</a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eeeee</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      descriptiontest
    
    </summary>
    
      <category term="Hexo教程" scheme="http://www.wunan520.cn/categories/Hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="标签2" scheme="http://www.wunan520.cn/tags/%E6%A0%87%E7%AD%BE2/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.wunan520.cn/2018/09/30/NotNeed/hello-world/"/>
    <id>http://www.wunan520.cn/2018/09/30/NotNeed/hello-world/</id>
    <published>2018-09-29T23:33:19.000Z</published>
    <updated>2018-09-29T23:33:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
